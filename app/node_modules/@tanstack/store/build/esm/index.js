/**
 * store
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
class Store {
  listeners = new Set();
  batching = false;
  queue = [];
  constructor(initialState, options) {
    this.state = initialState;
    this.options = options;
  }
  subscribe = listener => {
    this.listeners.add(listener);
    const unsub = this.options?.onSubscribe?.(listener, this);
    return () => {
      this.listeners.delete(listener);
      unsub?.();
    };
  };
  setState = updater => {
    const previous = this.state;
    this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);
    if (this.state === previous) return;
    this.options?.onUpdate?.(this.state, previous);
    this.queue.push(() => {
      this.listeners.forEach(listener => listener(this.state, previous));
    });
    this.#flush();
  };
  #flush = () => {
    if (this.batching) return;
    this.queue.forEach(cb => cb());
    this.queue = [];
  };
  batch = cb => {
    this.batching = true;
    cb();
    this.batching = false;
    this.#flush();
  };
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  // if (objA instanceof Map && objB instanceof Map) {
  //   if (objA.size !== objB.size) return false

  //   for (const [key, value] of objA) {
  //     if (!Object.is(value, objB.get(key))) {
  //       return false
  //     }
  //   }
  //   return true
  // }

  // if (objA instanceof Set && objB instanceof Set) {
  //   if (objA.size !== objB.size) return false

  //   for (const value of objA) {
  //     if (!objB.has(value)) {
  //       return false
  //     }
  //   }
  //   return true
  // }

  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

export { Store, shallow };
//# sourceMappingURL=index.js.map
