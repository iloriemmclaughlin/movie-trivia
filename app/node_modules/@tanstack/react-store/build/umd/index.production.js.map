{"version":3,"file":"index.production.js","sources":["../../../store/build/esm/index.js","../../src/index.tsx"],"sourcesContent":["/**\n * store\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Store {\n  listeners = new Set();\n  batching = false;\n  queue = [];\n  constructor(initialState, options) {\n    this.state = initialState;\n    this.options = options;\n  }\n  subscribe = listener => {\n    this.listeners.add(listener);\n    const unsub = this.options?.onSubscribe?.(listener, this);\n    return () => {\n      this.listeners.delete(listener);\n      unsub?.();\n    };\n  };\n  setState = updater => {\n    const previous = this.state;\n    this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);\n    if (this.state === previous) return;\n    this.options?.onUpdate?.(this.state, previous);\n    this.queue.push(() => {\n      this.listeners.forEach(listener => listener(this.state, previous));\n    });\n    this.#flush();\n  };\n  #flush = () => {\n    if (this.batching) return;\n    this.queue.forEach(cb => cb());\n    this.queue = [];\n  };\n  batch = cb => {\n    this.batching = true;\n    cb();\n    this.batching = false;\n    this.#flush();\n  };\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  // if (objA instanceof Map && objB instanceof Map) {\n  //   if (objA.size !== objB.size) return false\n\n  //   for (const [key, value] of objA) {\n  //     if (!Object.is(value, objB.get(key))) {\n  //       return false\n  //     }\n  //   }\n  //   return true\n  // }\n\n  // if (objA instanceof Set && objB instanceof Set) {\n  //   if (objA.size !== objB.size) return false\n\n  //   for (const value of objA) {\n  //     if (!objB.has(value)) {\n  //       return false\n  //     }\n  //   }\n  //   return true\n  // }\n\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { Store, shallow };\n//# sourceMappingURL=index.js.map\n","import { Store, AnyUpdater, shallow } from '@tanstack/store'\n\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport function useStore<\n  TState,\n  TSelected = NoInfer<TState>,\n  TUpdater extends AnyUpdater = AnyUpdater,\n>(\n  store: Store<TState, TUpdater>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n  compareShallow?: boolean,\n) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    compareShallow ? shallow : undefined,\n  )\n\n  return slice\n}\n\n"],"names":["shallow","objA","objB","Object","is","keysA","keys","length","i","prototype","hasOwnProperty","call","store","selector","d","compareShallow","useSyncExternalStoreWithSelector","subscribe","state","undefined"],"mappings":";;;;;;;;;;;;;;;;;;;;KAgDA,SAASA,EAAQC,EAAMC,GACrB,GAAIC,OAAOC,GAAGH,EAAMC,GAClB,OAAO,EAET,GAAoB,iBAATD,GAA8B,OAATA,GAAiC,iBAATC,GAA8B,OAATA,EAC3E,OAAO,EAyBT,MAAMG,EAAQF,OAAOG,KAAKL,GAC1B,GAAII,EAAME,SAAWJ,OAAOG,KAAKJ,GAAMK,OACrC,OAAO,EAET,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAME,OAAQC,IAChC,IAAKL,OAAOM,UAAUC,eAAeC,KAAKT,EAAMG,EAAMG,MAAQL,OAAOC,GAAGH,EAAKI,EAAMG,IAAKN,EAAKG,EAAMG,KACjG,OAAO,EAGX,OAAO,CACT,YClFO,SAKLI,EACAC,EAAmDC,IAAMA,GACzDC,GAUA,OARcC,EAAgCA,iCAC5CJ,EAAMK,WACN,IAAML,EAAMM,QACZ,IAAMN,EAAMM,OACZL,EACAE,EAAiBf,OAAUmB,EAI/B"}