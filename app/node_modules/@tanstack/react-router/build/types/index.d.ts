/**
 * react-router
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import * as React from 'react';
import { RegisteredRoutesInfo, LinkOptions, ToOptions, MatchRouteOptions, RouteByPath, ResolveRelativePath, NoInfer, ValidFromPath, NavigateOptions, RegisteredRouter, AnyRootRoute, RootRoute, AnyRoutesInfo, RoutesInfo, Router, RouterConstructorOptions, DefaultRoutesInfo, RouterOptions, RouterStore, RouteMatch, AnyRouteMatch } from '@tanstack/router';
export * from '@tanstack/router';
export { useStore } from '@tanstack/react-store';

type ReactNode = any;
type SyncRouteComponent<TProps = {}> = (props: TProps) => ReactNode;
type RouteComponent<TProps = {}> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
declare function lazy(importer: () => Promise<{
    default: SyncRouteComponent;
}>): RouteComponent;
type LinkPropsOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = LinkOptions<RegisteredRoutesInfo, TFrom, TTo> & {
    activeProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
    inactiveProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
};
type MakeUseMatchRouteOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> & MatchRouteOptions;
type MakeMatchRouteOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> & MatchRouteOptions & {
    children?: ReactNode | ((params: RouteByPath<RegisteredRoutesInfo, ResolveRelativePath<TFrom, NoInfer<TTo>>>['__types']['allParams']) => ReactNode);
};
type MakeLinkPropsOptions<TFrom extends ValidFromPath<RegisteredRoutesInfo> = '/', TTo extends string = ''> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>;
type MakeLinkOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement> & Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {
    children?: ReactNode | ((state: {
        isActive: boolean;
    }) => ReactNode);
};
declare module '@tanstack/router' {
    interface FrameworkGenerics {
        Component: RouteComponent;
        ErrorComponent: RouteComponent<{
            error: Error;
            info: {
                componentStack: string;
            };
        }>;
    }
    interface RouterOptions<TRouteTree> {
    }
    interface FrameworkRouteOptions {
        wrapInSuspense?: boolean;
    }
}
type PromptProps = {
    message: string;
    condition?: boolean | any;
    children?: ReactNode;
};
declare function useLinkProps<TFrom extends ValidFromPath<RegisteredRoutesInfo> = '/', TTo extends string = ''>(options: MakeLinkPropsOptions<TFrom, TTo>): React.AnchorHTMLAttributes<HTMLAnchorElement>;
interface LinkFn<TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/', TDefaultTo extends string = ''> {
    <TFrom extends RegisteredRoutesInfo['routePaths'] = TDefaultFrom, TTo extends string = TDefaultTo>(props: MakeLinkOptions<TFrom, TTo> & React.RefAttributes<HTMLAnchorElement>): ReactNode;
}
declare const Link: LinkFn;
declare function Navigate<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''>(props: NavigateOptions<RegisteredRoutesInfo, TFrom, TTo>): null;
type MatchesContextValue = AnyRouteMatch[];
declare const matchesContext: React.Context<MatchesContextValue>;
declare const routerContext: React.Context<{
    router: RegisteredRouter;
}>;
type MatchesProviderProps = {
    value: MatchesContextValue;
    children: ReactNode;
};
declare class ReactRouter<TRouteConfig extends AnyRootRoute = RootRoute, TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteConfig>> extends Router<TRouteConfig, TRoutesInfo> {
    constructor(opts: RouterConstructorOptions<TRouteConfig>);
}
type RouterProps<TRouteConfig extends AnyRootRoute = RootRoute, TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo> = RouterOptions<TRouteConfig> & {
    router: Router<TRouteConfig, TRoutesInfo>;
};
declare function RouterProvider<TRouteConfig extends AnyRootRoute = RootRoute, TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo>({ router, ...rest }: RouterProps<TRouteConfig, TRoutesInfo>): JSX.Element;
declare function useRouterContext(): RegisteredRouter;
declare function useRouter<T = RouterStore>(track?: (state: Router['__store']) => T, shallow?: boolean): RegisteredRouter;
declare function useMatches(): RouteMatch[];
declare function useMatch<TFrom extends keyof RegisteredRoutesInfo['routesById'], TStrict extends boolean = true, TRouteMatch = RouteMatch<RegisteredRoutesInfo, RegisteredRoutesInfo['routesById'][TFrom]>>(opts?: {
    from: TFrom;
    strict?: TStrict;
    track?: (match: TRouteMatch) => any;
    shallow?: boolean;
}): TStrict extends true ? TRouteMatch : TRouteMatch | undefined;
declare function useRoute<TId extends keyof RegisteredRoutesInfo['routesById'] = '/'>(routeId: TId): RegisteredRoutesInfo['routesById'][TId];
declare function useSearch<TFrom extends keyof RegisteredRoutesInfo['routesById'], TStrict extends boolean = true, TSearch = RegisteredRoutesInfo['routesById'][TFrom]['__types']['fullSearchSchema'], TSelected = TSearch>(opts?: {
    from: TFrom;
    strict?: TStrict;
    track?: (search: TSearch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
declare function useParams<TFrom extends keyof RegisteredRoutesInfo['routesById'] = '/', TDefaultSelected = RegisteredRoutesInfo['allParams'] & RegisteredRoutesInfo['routesById'][TFrom]['__types']['allParams'], TSelected = TDefaultSelected>(opts?: {
    from: TFrom;
    track?: (search: TDefaultSelected) => TSelected;
}): TSelected;
declare function useNavigate<TDefaultFrom extends keyof RegisteredRoutesInfo['routesById'] = '/'>(defaultOpts?: {
    from?: TDefaultFrom;
}): <TFrom extends string = TDefaultFrom, TTo extends string = "">(opts?: MakeLinkOptions<TFrom, TTo> | undefined) => Promise<void>;
declare function useMatchRoute(): <TFrom extends ValidFromPath<AnyRoutesInfo> = "/", TTo extends string = "">(opts: MakeUseMatchRouteOptions<TFrom, TTo>) => false | {};
declare function MatchRoute<TFrom extends ValidFromPath<RegisteredRoutesInfo> = '/', TTo extends string = ''>(props: MakeMatchRouteOptions<TFrom, TTo>): any;
declare function Outlet(): JSX.Element | null;
declare function ErrorComponent({ error }: {
    error: any;
}): JSX.Element;
declare function useBlocker(message: string, condition?: boolean | any): void;
declare function Block({ message, condition, children }: PromptProps): any;

export { Block, ErrorComponent, Link, LinkFn, LinkPropsOptions, MakeLinkOptions, MakeLinkPropsOptions, MakeMatchRouteOptions, MakeUseMatchRouteOptions, MatchRoute, MatchesProviderProps, Navigate, Outlet, PromptProps, ReactRouter, RouteComponent, RouterProps, RouterProvider, SyncRouteComponent, lazy, matchesContext, routerContext, useBlocker, useLinkProps, useMatch, useMatchRoute, useMatches, useNavigate, useParams, useRoute, useRouter, useRouterContext, useSearch };
