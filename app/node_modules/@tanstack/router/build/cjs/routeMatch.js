/**
 * router
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var store = require('@tanstack/store');
var router = require('./router.js');
var utils = require('./utils.js');

const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
class RouteMatch {
  abortController = new AbortController();
  constructor(router, route, opts) {
    Object.assign(this, {
      route,
      router,
      id: opts.id,
      pathname: opts.pathname,
      params: opts.params,
      __store: new store.Store({
        updatedAt: 0,
        routeSearch: {},
        search: {},
        status: 'idle'
      }, {
        onUpdate: next => {
          this.state = next;
        }
      })
    });
    this.state = this.__store.state;
    componentTypes.map(async type => {
      const component = this.route.options[type];
      if (typeof this[type] !== 'function') {
        this[type] = component;
      }
    });
    if (this.state.status === 'idle' && !this.#hasLoaders()) {
      this.__store.setState(s => ({
        ...s,
        status: 'success'
      }));
    }
  }
  #hasLoaders = () => {
    return !!(this.route.options.onLoad || componentTypes.some(d => this.route.options[d]?.preload));
  };
  __commit = () => {
    const {
      routeSearch,
      search,
      context,
      routeContext
    } = this.#resolveInfo({
      location: this.router.state.currentLocation
    });
    this.context = context;
    this.routeContext = routeContext;
    this.__store.setState(s => ({
      ...s,
      routeSearch: utils.replaceEqualDeep(s.routeSearch, routeSearch),
      search: utils.replaceEqualDeep(s.search, search)
    }));
  };
  cancel = () => {
    this.abortController?.abort();
  };
  #resolveSearchInfo = opts => {
    // Validate the search params and stabilize them
    const parentSearchInfo = this.parentMatch ? this.parentMatch.#resolveSearchInfo(opts) : {
      search: opts.location.search,
      routeSearch: opts.location.search
    };
    try {
      const validator = typeof this.route.options.validateSearch === 'object' ? this.route.options.validateSearch.parse : this.route.options.validateSearch;
      const routeSearch = validator?.(parentSearchInfo.search) ?? {};
      const search = {
        ...parentSearchInfo.search,
        ...routeSearch
      };
      return {
        routeSearch,
        search
      };
    } catch (err) {
      if (router.isRedirect(err)) {
        throw err;
      }
      const errorHandler = this.route.options.onValidateSearchError ?? this.route.options.onError;
      errorHandler?.(err);
      const error = new Error('Invalid search params found', {
        cause: err
      });
      error.code = 'INVALID_SEARCH_PARAMS';
      throw error;
    }
  };
  #resolveInfo = opts => {
    const {
      search,
      routeSearch
    } = this.#resolveSearchInfo(opts);
    try {
      const routeContext = this.route.options.getContext?.({
        parentContext: this.parentMatch?.routeContext ?? {},
        context: this.parentMatch?.context ?? this.router?.options.context ?? {},
        params: this.params,
        search
      }) || {};
      const context = {
        ...(this.parentMatch?.context ?? this.router?.options.context),
        ...routeContext
      };
      return {
        routeSearch,
        search,
        context,
        routeContext
      };
    } catch (err) {
      this.route.options.onError?.(err);
      throw err;
    }
  };
  __load = async opts => {
    this.parentMatch = opts.parentMatch;
    let info;
    try {
      info = this.#resolveInfo(opts);
    } catch (err) {
      if (router.isRedirect(err)) {
        if (!opts?.preload) {
          this.router.navigate(err);
        }
        return;
      }
      this.__store.setState(s => ({
        ...s,
        status: 'error',
        error: err
      }));

      // Do not proceed with loading the route
      return;
    }
    const {
      routeSearch,
      search,
      context,
      routeContext
    } = info;

    // If the match is invalid, errored or idle, trigger it to load
    if (this.state.status === 'pending') {
      return;
    }

    // TODO: Should load promises be tracked based on location?
    this.__loadPromise = Promise.resolve().then(async () => {
      const loadId = '' + Date.now() + Math.random();
      this.#latestId = loadId;
      const checkLatest = () => {
        return loadId !== this.#latestId ? this.__loadPromise : undefined;
      };
      let latestPromise;

      // If the match was in an error state, set it
      // to a loading state again. Otherwise, keep it
      // as loading or resolved
      if (this.state.status === 'idle') {
        this.__store.setState(s => ({
          ...s,
          status: 'pending'
        }));
      }
      const componentsPromise = (async () => {
        // then run all component and data loaders in parallel
        // For each component type, potentially load it asynchronously

        await Promise.all(componentTypes.map(async type => {
          const component = this.route.options[type];
          if (this[type]?.preload) {
            this[type] = await this.router.options.loadComponent(component);
          }
        }));
      })();
      const dataPromise = Promise.resolve().then(() => {
        if (this.route.options.onLoad) {
          return this.route.options.onLoad({
            params: this.params,
            routeSearch,
            search,
            signal: this.abortController.signal,
            preload: !!opts?.preload,
            routeContext: routeContext,
            context: context
          });
        }
        return;
      });
      try {
        await Promise.all([componentsPromise, dataPromise]);
        if (latestPromise = checkLatest()) return await latestPromise;
        this.__store.setState(s => ({
          ...s,
          error: undefined,
          status: 'success',
          updatedAt: Date.now()
        }));
      } catch (err) {
        if (router.isRedirect(err)) {
          if (!opts?.preload) {
            this.router.navigate(err);
          }
          return;
        }
        const errorHandler = this.route.options.onLoadError ?? this.route.options.onError;
        try {
          errorHandler?.(err);
        } catch (errorHandlerErr) {
          if (router.isRedirect(errorHandlerErr)) {
            if (!opts?.preload) {
              this.router.navigate(errorHandlerErr);
            }
            return;
          }
          this.__store.setState(s => ({
            ...s,
            error: errorHandlerErr,
            status: 'error',
            updatedAt: Date.now()
          }));
          return;
        }
        this.__store.setState(s => ({
          ...s,
          error: err,
          status: 'error',
          updatedAt: Date.now()
        }));
      } finally {
        delete this.__loadPromise;
      }
    });
    return this.__loadPromise;
  };
  #latestId = '';
}

exports.RouteMatch = RouteMatch;
//# sourceMappingURL=routeMatch.js.map
