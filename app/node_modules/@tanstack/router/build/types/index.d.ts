/**
 * router
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
export { default as invariant } from 'tiny-invariant';
export { default as warning } from 'tiny-warning';
import { Store } from '@tanstack/store';

interface RouterHistory {
    location: RouterLocation;
    listen: (cb: () => void) => () => void;
    push: (path: string, state: any) => void;
    replace: (path: string, state: any) => void;
    go: (index: number) => void;
    back: () => void;
    forward: () => void;
    createHref: (href: string) => string;
    block: (blockerFn: BlockerFn) => () => void;
}
interface ParsedPath {
    href: string;
    pathname: string;
    search: string;
    hash: string;
}
interface RouterLocation extends ParsedPath {
    state: any;
}
type BlockerFn = (retry: () => void, cancel: () => void) => void;
declare function createBrowserHistory(opts?: {
    getHref?: () => string;
    createHref?: (path: string) => string;
}): RouterHistory;
declare function createHashHistory(): RouterHistory;
declare function createMemoryHistory(opts?: {
    initialEntries: string[];
    initialIndex?: number;
}): RouterHistory;

interface FrameworkGenerics {
}
type GetFrameworkGeneric<U> = U extends keyof FrameworkGenerics ? FrameworkGenerics[U] : any;

type NoInfer<T> = [T][T extends any ? 0 : never];
type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N;
type IsAnyBoolean<T> = 1 extends 0 & T ? true : false;
type IsKnown<T, Y, N> = unknown extends T ? N : Y;
type PickAsRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
type PickAsPartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never;
type PickExtra<T, K> = {
    [TKey in keyof K as string extends TKey ? never : TKey extends keyof T ? never : TKey]: K[TKey];
};
type PickRequired<T> = {
    [K in keyof T as undefined extends T[K] ? never : K]: T[K];
};
type Expand<T> = T extends object ? T extends infer O ? {
    [K in keyof O]: O[K];
} : never : T;
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => any ? I : never;
type Compute<T> = {
    [K in keyof T]: T[K];
} | never;
type AllKeys<T> = T extends any ? keyof T : never;
type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<{
    [K in Keys]: T[Keys];
} & {
    [K in AllKeys<T>]?: T extends any ? K extends keyof T ? T[K] : never : never;
}>;
type Values<O> = O[ValueKeys<O>];
type ValueKeys<O> = Extract<keyof O, PropertyKey>;
type DeepAwaited<T> = T extends Promise<infer A> ? DeepAwaited<A> : T extends Record<infer A, Promise<infer B>> ? {
    [K in A]: DeepAwaited<B>;
} : T;
type PathParamMask<TRoutePath extends string> = TRoutePath extends `${infer L}/$${infer C}/${infer R}` ? PathParamMask<`${L}/${string}/${R}`> : TRoutePath extends `${infer L}/$${infer C}` ? PathParamMask<`${L}/${string}`> : TRoutePath;
type Timeout = ReturnType<typeof setTimeout>;
type Updater<TPrevious, TResult = TPrevious> = TResult | ((prev?: TPrevious) => TResult);
type PickExtract<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};
type PickExclude<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};
declare function last<T>(arr: T[]): T | undefined;
declare function functionalUpdate<TResult>(updater: Updater<TResult>, previous: TResult): TResult;
declare function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K>;
/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between immutable JSON values for example.
 * Do not use this with signals
 */
declare function replaceEqualDeep<T>(prev: any, _next: T): T;
declare function isPlainObject(o: any): boolean;
declare function partialDeepEqual(a: any, b: any): boolean;

interface Register {
}
type AnyRouter = Router<any, any>;
type RegisteredRouter = Register extends {
    router: Router<infer TRoute, infer TRoutesInfo>;
} ? Router<TRoute, TRoutesInfo> : Router;
type RegisteredRoutesInfo = Register extends {
    router: Router<infer TRoute, infer TRoutesInfo>;
} ? TRoutesInfo : AnyRoutesInfo;
interface LocationState {
}
interface ParsedLocation<TSearchObj extends AnySearchSchema = {}, TState extends LocationState = LocationState> {
    href: string;
    pathname: string;
    search: TSearchObj;
    searchStr: string;
    state: TState;
    hash: string;
    key?: string;
}
interface FromLocation {
    pathname: string;
    search?: unknown;
    key?: string;
    hash?: string;
}
type SearchSerializer = (searchObj: Record<string, any>) => string;
type SearchParser = (searchStr: string) => Record<string, any>;
type FilterRoutesFn = <TRoute extends AnyRoute>(routes: TRoute[]) => TRoute[];
type RouterContextOptions<TRouteTree extends AnyRoute> = AnyContext extends TRouteTree['__types']['routerContext'] ? {
    context?: TRouteTree['__types']['routerContext'];
} : {
    context: TRouteTree['__types']['routerContext'];
};
interface RouterOptions<TRouteTree extends AnyRoute> {
    history?: RouterHistory;
    stringifySearch?: SearchSerializer;
    parseSearch?: SearchParser;
    filterRoutes?: FilterRoutesFn;
    defaultPreload?: false | 'intent';
    defaultPreloadDelay?: number;
    defaultComponent?: GetFrameworkGeneric<'Component'>;
    defaultErrorComponent?: GetFrameworkGeneric<'ErrorComponent'>;
    defaultPendingComponent?: GetFrameworkGeneric<'Component'>;
    defaultLoaderMaxAge?: number;
    defaultLoaderGcMaxAge?: number;
    caseSensitive?: boolean;
    routeTree?: TRouteTree;
    basepath?: string;
    Router?: (router: AnyRouter) => void;
    createRoute?: (opts: {
        route: AnyRoute;
        router: AnyRouter;
    }) => void;
    loadComponent?: (component: GetFrameworkGeneric<'Component'>) => Promise<GetFrameworkGeneric<'Component'>>;
    onRouteChange?: () => void;
    fetchServerDataFn?: FetchServerDataFn;
    context?: TRouteTree['__types']['routerContext'];
}
type FetchServerDataFn = (ctx: {
    router: AnyRouter;
    routeMatch: RouteMatch;
}) => Promise<any>;
interface RouterStore<TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo, TState extends LocationState = LocationState> {
    status: 'idle' | 'pending';
    latestLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>;
    currentMatches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[];
    currentLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>;
    pendingMatches?: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[];
    pendingLocation?: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>;
    lastUpdated: number;
}
type ListenerFn = () => void;
interface BuildNextOptions {
    to?: string | number | null;
    params?: true | Updater<unknown>;
    search?: true | Updater<unknown>;
    hash?: true | Updater<string>;
    state?: LocationState;
    key?: string;
    from?: string;
    fromCurrent?: boolean;
    __matches?: RouteMatch[];
}
type MatchCacheEntry = {
    gc: number;
    match: RouteMatch;
};
interface MatchLocation {
    to?: string | number | null;
    fuzzy?: boolean;
    caseSensitive?: boolean;
    from?: string;
    fromCurrent?: boolean;
}
interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
interface DehydratedRouterState extends Pick<RouterStore, 'status' | 'latestLocation' | 'currentLocation' | 'lastUpdated'> {
    currentMatches: DehydratedRouteMatch[];
}
interface DehydratedRouter {
    state: DehydratedRouterState;
}
type MatchCache = Record<string, MatchCacheEntry>;
interface DehydratedRouteMatch {
    id: string;
    state: Pick<RouteMatchStore<any, any>, 'status'>;
}
interface RouterContext {
}
declare const defaultFetchServerDataFn: FetchServerDataFn;
type RouterConstructorOptions<TRouteTree extends AnyRoute> = Omit<RouterOptions<TRouteTree>, 'context'> & RouterContextOptions<TRouteTree>;
declare class Router<TRouteTree extends AnyRoute = RootRoute, TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>> {
    #private;
    types: {
        RootRoute: TRouteTree;
        RoutesInfo: TRoutesInfo;
    };
    options: PickAsRequired<RouterOptions<TRouteTree>, 'stringifySearch' | 'parseSearch' | 'context'>;
    history: RouterHistory;
    basepath: string;
    routeTree: RootRoute;
    routesById: RoutesById<TRoutesInfo>;
    navigateTimeout: undefined | Timeout;
    nextAction: undefined | 'push' | 'replace';
    navigationPromise: undefined | Promise<void>;
    __store: Store<RouterStore<TRoutesInfo>>;
    state: RouterStore<TRoutesInfo>;
    startedLoadingAt: number;
    resolveNavigation: () => void;
    constructor(options?: RouterConstructorOptions<TRouteTree>);
    reset: () => void;
    mount: () => () => void;
    update: (opts?: RouterOptions<TRouteTree>) => this;
    buildNext: (opts: BuildNextOptions) => ParsedLocation<{}, LocationState>;
    cancelMatches: () => void;
    safeLoad: (opts?: {
        next?: ParsedLocation;
    }) => void;
    load: (opts?: {
        next?: ParsedLocation;
    }) => Promise<void>;
    getRoute: <TId extends keyof TRoutesInfo["routesById"]>(id: TId) => TRoutesInfo["routesById"][TId];
    loadRoute: (navigateOpts?: BuildNextOptions) => Promise<RouteMatch[]>;
    preloadRoute: (navigateOpts?: BuildNextOptions) => Promise<AnyRouteMatch[]>;
    matchRoutes: (pathname: string, opts?: {
        strictParseParams?: boolean;
    }) => AnyRouteMatch[];
    loadMatches: (resolvedMatches: RouteMatch[], location: ParsedLocation, opts?: {
        preload?: boolean;
    }) => Promise<void>;
    reload: () => void;
    resolvePath: (from: string, path: string) => string;
    navigate: <TFrom extends ValidFromPath<TRoutesInfo> = "/", TTo extends string = "">({ from, to, search, hash, replace, params, }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => Promise<void>;
    matchRoute: <TFrom extends ValidFromPath<TRoutesInfo> = "/", TTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(location: ToOptions<TRoutesInfo, TFrom, TTo, ResolveRelativePath<TFrom, NoInfer<TTo>>>, opts?: MatchRouteOptions) => false | TRoutesInfo["routesById"][TResolved]["__types"]["allParams"];
    buildLink: <TFrom extends ValidFromPath<TRoutesInfo> = "/", TTo extends string = "">({ from, to, search, params, hash, target, replace, activeOptions, preload, preloadDelay: userPreloadDelay, disabled, }: LinkOptions<TRoutesInfo, TFrom, TTo>) => LinkInfo;
    dehydrate: () => DehydratedRouter;
    hydrate: (dehydratedRouter: DehydratedRouter) => void;
}
type AnyRedirect = Redirect<any, any, any>;
type Redirect<TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {
    code?: number;
};
declare function redirect<TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo>;
declare function isRedirect(obj: any): obj is AnyRedirect;

interface RouteMatchStore<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TRoute extends AnyRoute = Route> {
    routeSearch: TRoute['__types']['searchSchema'];
    search: TRoutesInfo['fullSearchSchema'] & TRoute['__types']['fullSearchSchema'];
    status: 'idle' | 'pending' | 'success' | 'error';
    error?: unknown;
    updatedAt: number;
}
interface PendingRouteMatchInfo {
    state: RouteMatchStore<any, any>;
    routeContext: {};
    context: {};
}
interface AnyRouteMatch extends RouteMatch<any, any> {
}
declare class RouteMatch<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TRoute extends AnyRoute = AnyRoute> {
    #private;
    route: TRoute;
    router: Router<TRoutesInfo['routeTree'], TRoutesInfo>;
    __store: Store<RouteMatchStore<TRoutesInfo, TRoute>>;
    state: RouteMatchStore<TRoutesInfo, TRoute>;
    id: string;
    pathname: string;
    params: TRoute['__types']['allParams'];
    routeContext?: TRoute['__types']['routeContext'];
    context?: TRoute['__types']['context'];
    component?: GetFrameworkGeneric<'Component'>;
    errorComponent?: GetFrameworkGeneric<'ErrorComponent'>;
    pendingComponent?: GetFrameworkGeneric<'Component'>;
    abortController: AbortController;
    parentMatch?: RouteMatch;
    pendingInfo?: PendingRouteMatchInfo;
    __loadPromise?: Promise<void>;
    __onExit?: void | ((matchContext: {
        params: TRoute['__types']['allParams'];
        search: TRoute['__types']['fullSearchSchema'];
    }) => void);
    constructor(router: AnyRouter, route: TRoute, opts: {
        id: string;
        params: TRoute['__types']['allParams'];
        pathname: string;
    });
    __commit: () => void;
    cancel: () => void;
    __load: (opts: {
        parentMatch: RouteMatch | undefined;
        preload?: boolean;
        location: ParsedLocation;
    }) => Promise<void>;
}

declare const rootRouteId: "__root__";
type RootRouteId = typeof rootRouteId;
type AnyLoaderData = {};
type AnyPathParams = {};
type AnySearchSchema = {};
type AnyContext = {};
interface RouteMeta {
}
interface RouteContext {
}
type RouteOptionsBase<TCustomId, TPath> = {
    path: TPath;
} | {
    id: TCustomId;
};
type RouteOptionsBaseIntersection<TCustomId, TPath> = UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>;
interface FrameworkRouteOptions {
}
type MetaOptions = keyof PickRequired<RouteMeta> extends never ? {
    meta?: RouteMeta;
} : {
    meta: RouteMeta;
};
type GetContextFn<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext> = (opts: {
    params: TAllParams;
    search: TFullSearchSchema;
} & (TParentRoute extends undefined ? {
    context?: TAllParentContext;
    parentContext?: TParentContext;
} : {
    context: TAllParentContext;
    parentContext: TParentContext;
})) => TRouteContext;
type ContextOptions<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext> = keyof PickRequired<RouteContext> extends never ? {
    getContext?: GetContextFn<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext>;
} : {
    getContext: GetContextFn<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext>;
};
type RouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TParentSearchSchema extends {} = {}, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = TSearchSchema, TParentParams extends AnyPathParams = {}, TParams extends Record<ParsePathParams<TPath>, any> = Record<ParsePathParams<TPath>, string>, TAllParams = TParams, TParentContext extends AnyContext = AnyContext, TAllParentContext extends AnyContext = AnyContext, TRouteContext extends RouteContext = RouteContext, TContext extends AnyContext = TRouteContext> = RouteOptionsBase<TCustomId, TPath> & FrameworkRouteOptions & {
    getParentRoute: () => TParentRoute;
    caseSensitive?: boolean;
    preSearchFilters?: SearchFilter<TFullSearchSchema>[];
    postSearchFilters?: SearchFilter<TFullSearchSchema>[];
    component?: GetFrameworkGeneric<'Component'>;
    errorComponent?: GetFrameworkGeneric<'ErrorComponent'>;
    pendingComponent?: GetFrameworkGeneric<'Component'>;
    beforeLoad?: (opts: {
        router: AnyRouter;
        match: RouteMatch;
    }) => Promise<void> | void;
    onBeforeLoadError?: (err: any) => void;
    validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>;
    onValidateSearchError?: (err: any) => void;
    onLoad?: OnLoadFn<TSearchSchema, TFullSearchSchema, TAllParams, NoInfer<TRouteContext>, TContext>;
    onLoadError?: (err: any) => void;
    onError?: (err: any) => void;
    onLoaded?: (matchContext: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void | undefined | ((match: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void);
    onTransition?: (match: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void;
} & MetaOptions & ContextOptions<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext> & ({
    parseParams?: (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<string, any> ? TParams : 'parseParams must return a Record<string, any>';
    stringifyParams?: (params: NoInfer<TParams>) => Record<ParsePathParams<TPath>, string>;
} | {
    stringifyParams?: never;
    parseParams?: never;
}) & (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never ? {} : 'Cannot redefined path params in child routes!');
type SearchSchemaValidator<TReturn, TParentSchema> = SearchSchemaValidatorObj<TReturn, TParentSchema> | SearchSchemaValidatorFn<TReturn, TParentSchema>;
type SearchSchemaValidatorObj<TReturn, TParentSchema> = {
    parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>;
};
type SearchSchemaValidatorFn<TReturn, TParentSchema> = (searchObj: Record<string, unknown>) => {} extends TParentSchema ? TReturn : keyof TReturn extends keyof TParentSchema ? {
    error: 'Top level search params cannot be redefined by child routes!';
    keys: keyof TReturn & keyof TParentSchema;
} : TReturn;
type DefinedPathParamWarning = 'Path params cannot be redefined by child routes!';
type ParentParams<TParentParams> = AnyPathParams extends TParentParams ? {} : {
    [Key in keyof TParentParams]?: DefinedPathParamWarning;
};
type OnLoadFn<TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = {}, TAllParams = {}, TContext extends AnyContext = AnyContext, TAllContext extends AnyContext = AnyContext> = (loaderContext: LoaderContext<TSearchSchema, TFullSearchSchema, TAllParams, TContext, TAllContext>) => Promise<any> | void;
interface LoaderContext<TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = {}, TAllParams = {}, TContext extends AnyContext = AnyContext, TAllContext extends AnyContext = AnyContext> {
    params: TAllParams;
    routeSearch: TSearchSchema;
    search: TFullSearchSchema;
    signal?: AbortSignal;
    preload: boolean;
    routeContext: TContext;
    context: TAllContext;
}
type UnloaderFn<TPath extends string> = (routeMatch: RouteMatch<any, Route>) => void;
type SearchFilter<T, U = T> = (prev: T) => U;
type ResolveId<TParentRoute, TCustomId extends string, TPath extends string> = TParentRoute extends {
    id: infer TParentId extends string;
} ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId> : RootRouteId;
type InferFullSearchSchema<TRoute> = TRoute extends {
    isRoot: true;
    __types: {
        searchSchema: infer TSearchSchema;
    };
} ? TSearchSchema : TRoute extends {
    __types: {
        fullSearchSchema: infer TFullSearchSchema;
    };
} ? TFullSearchSchema : {};
type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = InferFullSearchSchema<TParentRoute> & TSearchSchema;
interface AnyRoute extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
type MergeFromParent<T, U> = IsAny<T, U, T & U>;
declare class Route<TParentRoute extends AnyRoute = AnyRoute, TPath extends string = string, TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<TParentRoute, TPath>, TCustomId extends string = string, TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<TParentRoute, TCustomId, TPath>, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends Record<ParsePathParams<TPath>, any> = Record<ParsePathParams<TPath>, string>, TAllParams extends MergeFromParent<TParentRoute['__types']['allParams'], TParams> = MergeFromParent<TParentRoute['__types']['allParams'], TParams>, TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'], TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'], TRouteContext extends RouteContext = RouteContext, TContext extends MergeFromParent<TParentRoute['__types']['context'], TRouteContext> = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>, TRouterContext extends AnyContext = AnyContext, TChildren extends unknown = unknown, TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo> {
    __types: {
        parentRoute: TParentRoute;
        path: TPath;
        fullPath: TFullPath;
        customId: TCustomId;
        id: TId;
        searchSchema: TSearchSchema;
        fullSearchSchema: TFullSearchSchema;
        params: TParams;
        allParams: TAllParams;
        parentContext: TParentContext;
        allParentContext: TAllParentContext;
        routeContext: TRouteContext;
        context: TContext;
        children: TChildren;
        routesInfo: TRoutesInfo;
        routerContext: TRouterContext;
    };
    isRoot: TParentRoute extends Route<any> ? true : false;
    options: RouteOptions<TParentRoute, TCustomId, TPath, InferFullSearchSchema<TParentRoute>, TSearchSchema, InferFullSearchSchema<TParentRoute> & TSearchSchema, TParentRoute['__types']['allParams'], TParams, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext>;
    parentRoute: TParentRoute;
    id: TId;
    path: TPath;
    fullPath: TFullPath;
    children?: TChildren;
    originalIndex?: number;
    router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>;
    constructor(options: RouteOptions<TParentRoute, TCustomId, TPath, InferFullSearchSchema<TParentRoute>, TSearchSchema, TFullSearchSchema, TParentRoute['__types']['allParams'], TParams, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext>);
    init: (opts: {
        originalIndex: number;
        router: AnyRouter;
    }) => void;
    addChildren: <TNewChildren extends AnyRoute[]>(children: TNewChildren) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext, TRouterContext, TNewChildren, TRoutesInfo>;
}
type AnyRootRoute = RootRoute<any, any, any>;
declare class RootRoute<TSearchSchema extends AnySearchSchema = {}, TContext extends RouteContext = RouteContext, TRouterContext extends RouterContext = RouterContext> extends Route<any, '/', '/', string, RootRouteId, TSearchSchema, TSearchSchema, {}, {}, TRouterContext, TRouterContext, TContext, MergeFromParent<TRouterContext, TContext>, TRouterContext> {
    constructor(options?: Omit<RouteOptions<AnyRoute, RootRouteId, '', {}, TSearchSchema, NoInfer<TSearchSchema>, {}, TRouterContext, TRouterContext, TContext, NoInfer<TContext>>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams'>);
    static withRouterContext: <TRouterContext_1 extends RouterContext>() => <TSearchSchema_1 extends AnySearchSchema = {}, TContext_1 extends RouterContext = RouterContext>(options?: Omit<RouteOptions<AnyRoute, "__root__", "", {}, TSearchSchema_1, NoInfer<TSearchSchema_1>, {}, TRouterContext_1, TRouterContext_1, TContext_1, TRouterContext_1 & TContext_1, RouteContext, RouteContext>, "caseSensitive" | "id" | "path" | "getParentRoute"> | undefined) => RootRoute<TSearchSchema_1, TContext_1, TRouterContext_1>;
}
type ResolveFullPath<TParentRoute extends AnyRoute, TPath extends string, TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<TParentRoute['fullPath'], TPath>> = TPrefixed extends RootRouteId ? '/' : TrimPathRight<`${TPrefixed}`>;
type RoutePrefix<TPrefix extends string, TId extends string> = string extends TId ? RootRouteId : TId extends string ? TPrefix extends RootRouteId ? TId extends '/' ? '/' : `/${TrimPath<TId>}` : `${TPrefix}/${TId}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}` : never;
type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;

interface AnyRoutesInfo {
    routeTree: AnyRootRoute;
    routeUnion: AnyRoute;
    routesById: Record<string, AnyRoute>;
    routesByFullPath: Record<string, AnyRoute>;
    routeIds: any;
    routePaths: any;
    routeIntersection: AnyRoute;
    fullSearchSchema: Record<string, any>;
    allParams: Record<string, any>;
}
interface DefaultRoutesInfo {
    routeTree: RootRoute;
    routeUnion: AnyRoute;
    routesById: Record<string, Route>;
    routesByFullPath: Record<string, Route>;
    routeIds: string;
    routePaths: string;
    routeIntersection: AnyRoute;
    fullSearchSchema: AnySearchSchema;
    allParams: AnyPathParams;
}
interface RoutesInfo<TRouteTree extends AnyRoute = Route> extends RoutesInfoInner<TRouteTree, ParseRoute<TRouteTree>> {
}
interface RoutesInfoInner<TRouteTree extends AnyRoute, TRouteUnion extends AnyRoute = Route, TRoutesById = {
    '/': TRouteUnion;
} & {
    [TRoute in TRouteUnion as TRoute['id']]: TRoute;
}, TRoutesByFullPath = {
    '/': TRouteUnion;
} & {
    [TRoute in TRouteUnion as TRoute['fullPath'] extends RootRouteId ? never : string extends TRoute['fullPath'] ? never : TRoute['fullPath']]: TRoute;
}> {
    routeTree: TRouteTree;
    routeUnion: TRouteUnion;
    routesById: TRoutesById;
    routesByFullPath: TRoutesByFullPath;
    routeIds: keyof TRoutesById;
    routePaths: keyof TRoutesByFullPath;
    routeIntersection: Route<TRouteUnion['__types']['parentRoute'], // TParentRoute,
    TRouteUnion['__types']['path'], // TPath,
    TRouteUnion['__types']['fullPath'], // TFullPath,
    TRouteUnion['__types']['customId'], // TCustomId,
    TRouteUnion['__types']['id'], // TId,
    // TId,
    MergeUnion<TRouteUnion['__types']['searchSchema']> & {}, // TSearchSchema,
    // TSearchSchema,
    MergeUnion<TRouteUnion['__types']['fullSearchSchema']> & {}, // TFullSearchSchema,
    MergeUnion<TRouteUnion['__types']['params']>, // TParams,
    MergeUnion<TRouteUnion['__types']['allParams']>, // TAllParams,
    MergeUnion<TRouteUnion['__types']['parentContext']>, // TParentContext,
    MergeUnion<TRouteUnion['__types']['allParentContext']>, // TAllParentContext,
    // TAllParentContext,
    MergeUnion<TRouteUnion['__types']['routeContext']> & {}, // TRouteContext,
    // TRouteContext,
    MergeUnion<TRouteUnion['__types']['context']> & {}, // TContext,
    // TContext,
    MergeUnion<TRouteUnion['__types']['routerContext']> & {}, // TRouterContext,
    TRouteUnion['__types']['children'], // TChildren,
    TRouteUnion['__types']['routesInfo']>;
    fullSearchSchema: Partial<MergeUnion<TRouteUnion['__types']['fullSearchSchema']>>;
    allParams: Partial<MergeUnion<TRouteUnion['__types']['allParams']>>;
}
type ParseRoute<TRouteTree> = TRouteTree extends AnyRoute ? TRouteTree | ParseRouteChildren<TRouteTree> : never;
type ParseRouteChildren<TRouteTree> = TRouteTree extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, infer TChildren, any> ? unknown extends TChildren ? never : TChildren extends AnyRoute[] ? Values<{
    [TId in TChildren[number]['id']]: ParseRouteChild<TChildren[number], TId>;
}> : never : never;
type ParseRouteChild<TRoute, TId> = TRoute extends AnyRoute ? ParseRoute<TRoute> : never;
type RoutesById<TRoutesInfo extends AnyRoutesInfo> = {
    [K in keyof TRoutesInfo['routesById']]: TRoutesInfo['routesById'][K];
};
type RouteById<TRoutesInfo extends AnyRoutesInfo, TId> = TId extends keyof TRoutesInfo['routesById'] ? IsAny<TRoutesInfo['routesById'][TId]['id'], Route, TRoutesInfo['routesById'][TId]> : never;
type RouteByPath<TRoutesInfo extends AnyRoutesInfo, TPath> = TPath extends keyof TRoutesInfo['routesByFullPath'] ? IsAny<TRoutesInfo['routesByFullPath'][TPath]['id'], Route, TRoutesInfo['routesByFullPath'][TPath]> : never;

type LinkInfo = {
    type: 'external';
    href: string;
} | {
    type: 'internal';
    next: ParsedLocation;
    handleFocus: (e: any) => void;
    handleClick: (e: any) => void;
    handleEnter: (e: any) => void;
    handleLeave: (e: any) => void;
    handleTouchStart: (e: any) => void;
    isActive: boolean;
    disabled?: boolean;
};
type CleanPath<T extends string> = T extends `${infer L}//${infer R}` ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`> : T extends `${infer L}//` ? `${CleanPath<L>}/` : T extends `//${infer L}` ? `/${CleanPath<L>}` : T;
type Split<S, TIncludeTrailingSlash = true> = S extends unknown ? string extends S ? string[] : S extends string ? CleanPath<S> extends '' ? [] : TIncludeTrailingSlash extends true ? CleanPath<S> extends `${infer T}/` ? [...Split<T>, '/'] : CleanPath<S> extends `/${infer U}` ? Split<U> : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : [S] : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : S extends string ? [S] : never : never : never;
type ParsePathParams<T extends string> = Split<T>[number] extends infer U ? U extends `$${infer V}` ? V : never : never;
type Join<T> = T extends [] ? '' : T extends [infer L extends string] ? L : T extends [infer L extends string, ...infer Tail extends [...string[]]] ? CleanPath<`${L}/${Join<Tail>}`> : never;
type RelativeToPathAutoComplete<AllPaths extends string, TFrom extends string, TTo extends string, SplitPaths extends string[] = Split<AllPaths, false>> = TTo extends `..${infer _}` ? SplitPaths extends [
    ...Split<ResolveRelativePath<TFrom, TTo>, false>,
    ...infer TToRest
] ? `${CleanPath<Join<[
    ...Split<TTo, false>,
    ...(TToRest | (Split<ResolveRelativePath<TFrom, TTo>, false>['length'] extends 1 ? never : ['../']))
]>>}` : never : TTo extends `./${infer RestTTo}` ? SplitPaths extends [
    ...Split<TFrom, false>,
    ...Split<RestTTo, false>,
    ...infer RestPath
] ? `${TTo}${Join<RestPath>}` : never : (TFrom extends `/` ? never : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath] ? Join<RestPath> extends {
    length: 0;
} ? never : './' : never) | (TFrom extends `/` ? never : '../') | AllPaths;
type NavigateOptions<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''> = ToOptions<TRoutesInfo, TFrom, TTo> & {
    replace?: boolean;
};
type ToOptions<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = '', TResolvedTo = ResolveRelativePath<TFrom, NoInfer<TTo>>> = {
    to?: ToPathOption<TRoutesInfo, TFrom, TTo>;
    hash?: Updater<string>;
    state?: LocationState;
    from?: TFrom;
} & CheckPath<TRoutesInfo, NoInfer<TResolvedTo>, {}> & SearchParamOptions<TRoutesInfo, TFrom, TResolvedTo> & PathParamOptions<TRoutesInfo, TFrom, TResolvedTo>;
type SearchParamOptions<TRoutesInfo extends AnyRoutesInfo, TFrom, TTo, TFromSchema = UnionToIntersection<TRoutesInfo['fullSearchSchema'] & RouteByPath<TRoutesInfo, TFrom> extends never ? {} : RouteByPath<TRoutesInfo, TFrom>['__types']['fullSearchSchema']>, TToSchema = Partial<RouteByPath<TRoutesInfo, TFrom>['__types']['fullSearchSchema']> & Omit<RouteByPath<TRoutesInfo, TTo>['__types']['fullSearchSchema'], keyof PickRequired<RouteByPath<TRoutesInfo, TFrom>['__types']['fullSearchSchema']>>, TFromFullSchema = UnionToIntersection<TRoutesInfo['fullSearchSchema'] & TFromSchema>, TToFullSchema = UnionToIntersection<TRoutesInfo['fullSearchSchema'] & TToSchema>> = keyof PickRequired<TToSchema> extends never ? {
    search?: true | SearchReducer<TFromFullSchema, TToFullSchema>;
} : {
    search: SearchReducer<TFromFullSchema, TToFullSchema>;
};
type SearchReducer<TFrom, TTo> = {
    [TKey in keyof TTo]: TTo[TKey];
} | ((current: TFrom) => TTo);
type PathParamOptions<TRoutesInfo extends AnyRoutesInfo, TFrom, TTo, TFromSchema = UnionToIntersection<RouteByPath<TRoutesInfo, TFrom> extends never ? {} : RouteByPath<TRoutesInfo, TFrom>['__types']['allParams']>, TToSchema = Partial<RouteByPath<TRoutesInfo, TFrom>['__types']['allParams']> & Omit<RouteByPath<TRoutesInfo, TTo>['__types']['allParams'], keyof PickRequired<RouteByPath<TRoutesInfo, TFrom>['__types']['allParams']>>, TFromFullParams = UnionToIntersection<TRoutesInfo['allParams'] & TFromSchema>, TToFullParams = UnionToIntersection<TRoutesInfo['allParams'] & TToSchema>> = keyof PickRequired<TToSchema> extends never ? {
    params?: ParamsReducer<TFromFullParams, TToFullParams>;
} : {
    params: ParamsReducer<TFromFullParams, TToFullParams>;
};
type ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo);
type ToPathOption<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''> = TTo | RelativeToPathAutoComplete<TRoutesInfo['routePaths'], NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
type ToIdOption<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''> = TTo | RelativeToPathAutoComplete<TRoutesInfo['routeIds'], NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
interface ActiveOptions {
    exact?: boolean;
    includeHash?: boolean;
    includeSearch?: boolean;
}
type LinkOptions<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {
    target?: HTMLAnchorElement['target'];
    activeOptions?: ActiveOptions;
    preload?: false | 'intent';
    preloadDelay?: number;
    disabled?: boolean;
};
type CheckRelativePath<TRoutesInfo extends AnyRoutesInfo, TFrom, TTo> = TTo extends string ? TFrom extends string ? ResolveRelativePath<TFrom, TTo> extends TRoutesInfo['routePaths'] ? {} : {
    Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<TFrom, TTo>}, which is not a valid route path.`;
    'Valid Route Paths': TRoutesInfo['routePaths'];
} : {} : {};
type CheckPath<TRoutesInfo extends AnyRoutesInfo, TPath, TPass> = Exclude<TPath, TRoutesInfo['routePaths']> extends never ? TPass : CheckPathError<TRoutesInfo, Exclude<TPath, TRoutesInfo['routePaths']>>;
type CheckPathError<TRoutesInfo extends AnyRoutesInfo, TInvalids> = {
    Error: `${TInvalids extends string ? TInvalids : never} is not a valid route path.`;
    'Valid Route Paths': TRoutesInfo['routePaths'];
};
type CheckId<TRoutesInfo extends AnyRoutesInfo, TPath, TPass> = Exclude<TPath, TRoutesInfo['routeIds']> extends never ? TPass : CheckIdError<TRoutesInfo, Exclude<TPath, TRoutesInfo['routeIds']>>;
type CheckIdError<TRoutesInfo extends AnyRoutesInfo, TInvalids> = {
    Error: `${TInvalids extends string ? TInvalids : never} is not a valid route ID.`;
    'Valid Route IDs': TRoutesInfo['routeIds'];
};
type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string ? TTo extends string ? TTo extends '.' ? TFrom : TTo extends `./` ? Join<[TFrom, '/']> : TTo extends `./${infer TRest}` ? ResolveRelativePath<TFrom, TRest> : TTo extends `/${infer TRest}` ? TTo : Split<TTo> extends ['..', ...infer ToRest] ? Split<TFrom> extends [...infer FromRest, infer FromTail] ? ToRest extends ['/'] ? Join<[...FromRest, '/']> : ResolveRelativePath<Join<FromRest>, Join<ToRest>> : never : Split<TTo> extends ['.', ...infer ToRest] ? ToRest extends ['/'] ? Join<[TFrom, '/']> : ResolveRelativePath<TFrom, Join<ToRest>> : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>> : never : never;
type ValidFromPath<TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo> = undefined | (string extends TRoutesInfo['routePaths'] ? string : TRoutesInfo['routePaths']);

interface Segment {
    type: 'pathname' | 'param' | 'wildcard';
    value: string;
}
declare function joinPaths(paths: (string | undefined)[]): string;
declare function cleanPath(path: string): string;
declare function trimPathLeft(path: string): string;
declare function trimPathRight(path: string): string;
declare function trimPath(path: string): string;
declare function resolvePath(basepath: string, base: string, to: string): string;
declare function parsePathname(pathname?: string): Segment[];
declare function interpolatePath(path: string | undefined, params: any, leaveWildcard?: boolean): string;
declare function matchPathname(basepath: string, currentPathname: string, matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>): AnyPathParams | undefined;
declare function matchByPath(basepath: string, from: string, matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>): Record<string, string> | undefined;

declare function encode(obj: any, pfx?: string): string;
declare function decode(str: any): {};

declare const defaultParseSearch: (searchStr: string) => AnySearchSchema;
declare const defaultStringifySearch: (search: Record<string, any>) => string;
declare function parseSearchWith(parser: (str: string) => any): (searchStr: string) => AnySearchSchema;
declare function stringifySearchWith(stringify: (search: any) => string): (search: Record<string, any>) => string;

export { ActiveOptions, AnyContext, AnyLoaderData, AnyPathParams, AnyRedirect, AnyRootRoute, AnyRoute, AnyRouteMatch, AnyRouter, AnyRoutesInfo, AnySearchSchema, BuildNextOptions, CheckId, CheckIdError, CheckPath, CheckPathError, CheckRelativePath, ContextOptions, DeepAwaited, DefaultRoutesInfo, DefinedPathParamWarning, DehydratedRouter, DehydratedRouterState, Expand, FilterRoutesFn, FrameworkGenerics, FrameworkRouteOptions, FromLocation, GetFrameworkGeneric, InferFullSearchSchema, IsAny, IsAnyBoolean, IsKnown, LinkInfo, LinkOptions, ListenerFn, LoaderContext, LocationState, MatchCache, MatchCacheEntry, MatchLocation, MatchRouteOptions, MergeUnion, MetaOptions, NavigateOptions, NoInfer, OnLoadFn, ParentParams, ParsePathParams, ParseRoute, ParseRouteChild, ParseRouteChildren, ParsedLocation, ParsedPath, PathParamMask, PathParamOptions, PendingRouteMatchInfo, PickAsPartial, PickAsRequired, PickExclude, PickExtra, PickExtract, PickRequired, PickUnsafe, Redirect, Register, RegisteredRouter, RegisteredRoutesInfo, RelativeToPathAutoComplete, ResolveFullSearchSchema, ResolveRelativePath, RootRoute, RootRouteId, Route, RouteById, RouteByPath, RouteContext, RouteMatch, RouteMatchStore, RouteMeta, RouteOptions, RouteOptionsBase, RouteOptionsBaseIntersection, Router, RouterConstructorOptions, RouterContext, RouterHistory, RouterLocation, RouterOptions, RouterStore, RoutesById, RoutesInfo, RoutesInfoInner, SearchFilter, SearchParamOptions, SearchParser, SearchSchemaValidator, SearchSchemaValidatorFn, SearchSchemaValidatorObj, SearchSerializer, Segment, Split, Timeout, ToIdOption, ToOptions, ToPathOption, UnionToIntersection, UnloaderFn, Updater, ValidFromPath, ValueKeys, Values, cleanPath, createBrowserHistory, createHashHistory, createMemoryHistory, decode, defaultFetchServerDataFn, defaultParseSearch, defaultStringifySearch, encode, functionalUpdate, interpolatePath, isPlainObject, isRedirect, joinPaths, last, matchByPath, matchPathname, parsePathname, parseSearchWith, partialDeepEqual, pick, redirect, replaceEqualDeep, resolvePath, rootRouteId, stringifySearchWith, trimPath, trimPathLeft, trimPathRight };
