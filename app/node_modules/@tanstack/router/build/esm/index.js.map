{"version":3,"file":"index.js","sources":["../../src/history.ts","../../src/utils.ts","../../src/path.ts","../../src/qss.ts","../../src/route.ts","../../src/searchParams.ts","../../src/router.ts","../../src/routeMatch.ts"],"sourcesContent":["// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: RouterLocation\n  listen: (cb: () => void) => () => void\n  push: (path: string, state: any) => void\n  replace: (path: string, state: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blockerFn: BlockerFn) => () => void\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface RouterLocation extends ParsedPath {\n  state: any\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void\n\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nfunction createHistory(opts: {\n  getLocation: () => RouterLocation\n  listener: (onUpdate: () => void) => () => void\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n}): RouterHistory {\n  let currentLocation = opts.getLocation()\n  let unsub = () => {}\n  let listeners = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n  let queue: (() => void)[] = []\n\n  const tryFlush = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryFlush, () => {\n        blockers = []\n        stopBlocking()\n      })\n      return\n    }\n\n    while (queue.length) {\n      queue.shift()?.()\n    }\n\n    onUpdate()\n  }\n\n  const queueTask = (task: () => void) => {\n    queue.push(task)\n    tryFlush()\n  }\n\n  const onUpdate = () => {\n    currentLocation = opts.getLocation()\n    listeners.forEach((listener) => listener())\n  }\n\n  return {\n    get location() {\n      return currentLocation\n    },\n    listen: (cb: () => void) => {\n      if (listeners.size === 0) {\n        unsub = opts.listener(onUpdate)\n      }\n      listeners.add(cb)\n\n      return () => {\n        listeners.delete(cb)\n        if (listeners.size === 0) {\n          unsub()\n        }\n      }\n    },\n    push: (path: string, state: any) => {\n      queueTask(() => {\n        opts.pushState(path, state)\n      })\n    },\n    replace: (path: string, state: any) => {\n      queueTask(() => {\n        opts.replaceState(path, state)\n      })\n    },\n    go: (index) => {\n      queueTask(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (cb) => {\n      blockers.push(cb)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== cb)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n  }\n}\n\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.hash}${window.location.search}`)\n  const createHref = opts?.createHref ?? ((path) => path)\n  const getLocation = () => parseLocation(getHref(), history.state)\n\n  return createHistory({\n    getLocation,\n    listener: (onUpdate) => {\n      window.addEventListener(popStateEvent, onUpdate)\n      return () => {\n        window.removeEventListener(popStateEvent, onUpdate)\n      }\n    },\n    pushState: (path, state) => {\n      window.history.pushState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    replaceState: (path, state) => {\n      window.history.replaceState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n    createHref: (path) => createHref(path),\n  })\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {}\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    listener: () => {\n      return () => {}\n    },\n    pushState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n    createHref: (path) => path,\n  })\n}\n\nfunction parseLocation(href: string, state: any): RouterLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex, searchIndex) : '',\n    search: searchIndex > -1 ? href.substring(searchIndex) : '',\n    state,\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n","export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\ntype Compute<T> = { [K in keyof T]: T[K] } | never\n\ntype AllKeys<T> = T extends any ? keyof T : never\n\nexport type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n  {\n    [K in Keys]: T[Keys]\n  } & {\n    [K in AllKeys<T>]?: T extends any\n      ? K extends keyof T\n        ? T[K]\n        : never\n      : never\n  }\n>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nexport function warning(cond: any, message: string): cond is true {\n  if (cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n\n  return true\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return (\n      a.length === b.length &&\n      a.every((item, index) => partialDeepEqual(item, b[index]))\n    )\n  }\n\n  return false\n}\n","import invariant from 'tiny-invariant'\nimport { AnyPathParams } from './route'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (['$', '*'].includes(segment.value) && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(currentLocation.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  if (!from.startsWith(basepath)) {\n    return undefined\n  }\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  const baseSegments = parsePathname(from)\n  const to = `${matchLocation.to ?? '$'}`\n  const routeSegments = parsePathname(to)\n\n  if (last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  if (str.charAt(0) === '0') return str\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import { GetFrameworkGeneric } from './frameworks'\nimport { ParsePathParams } from './link'\nimport { RouteMatch } from './routeMatch'\nimport { AnyRouter, Router, RouterContext } from './router'\nimport {\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  PickUnsafe,\n  UnionToIntersection,\n} from './utils'\nimport invariant from 'tiny-invariant'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { DefaultRoutesInfo } from './routeInfo'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\n\nexport type AnyLoaderData = {}\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport type AnyContext = {}\nexport interface RouteMeta {}\nexport interface RouteContext {}\n\nexport type RouteOptionsBase<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RouteOptionsBaseIntersection<TCustomId, TPath> =\n  UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>\n\nexport interface FrameworkRouteOptions {}\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\ntype GetContextFn<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = (\n  opts: {\n    params: TAllParams\n    search: TFullSearchSchema\n  } & (TParentRoute extends undefined\n    ? {\n        context?: TAllParentContext\n        parentContext?: TParentContext\n      }\n    : {\n        context: TAllParentContext\n        parentContext: TParentContext\n      }),\n) => TRouteContext\n\nexport type ContextOptions<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = keyof PickRequired<RouteContext> extends never\n  ? {\n      getContext?: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n  : {\n      getContext: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams extends Record<ParsePathParams<TPath>, any> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams = TParams,\n  TParentContext extends AnyContext = AnyContext,\n  TAllParentContext extends AnyContext = AnyContext,\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends AnyContext = TRouteContext,\n> = RouteOptionsBase<TCustomId, TPath> &\n  FrameworkRouteOptions & {\n    getParentRoute: () => TParentRoute\n    // If true, this route will be matched as case-sensitive\n    caseSensitive?: boolean\n    // Filter functions that can manipulate search params *before* they are passed to links and navigate\n    // calls that match this route.\n    preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n    // Filter functions that can manipulate search params *after* they are passed to links and navigate\n    // calls that match this route.\n    postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n    // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n    component?: GetFrameworkGeneric<'Component'> // , NoInfer<TParentAllLoaderData>>\n    // The content to be rendered when the route encounters an error\n    errorComponent?: GetFrameworkGeneric<'ErrorComponent'> // , NoInfer<TParentAllLoaderData>>\n    // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n    pendingComponent?: GetFrameworkGeneric<'Component'> //, NoInfer<TParentAllLoaderData>>\n    // This async function is called before a route is loaded.\n    // If an error is thrown here, the route's loader will not be called.\n    // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n    // If thrown during a preload event, the error will be logged to the console.\n    beforeLoad?: (opts: {\n      router: AnyRouter\n      match: RouteMatch\n    }) => Promise<void> | void\n    // This function will be called if the route's loader throws an error **during an attempted navigation**.\n    // If you want to redirect due to an error, call `router.navigate()` from within this function.\n    onBeforeLoadError?: (err: any) => void\n    validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n    // This function will be called if the route's validateSearch option throws an error **during an attempted validation**.\n    // If you want to redirect due to an error, call `router.navigate()` from within this function.\n    // If you want to display the errorComponent, rethrow the error\n    onValidateSearchError?: (err: any) => void\n    // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n    onLoad?: OnLoadFn<\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      NoInfer<TRouteContext>,\n      TContext\n    >\n    onLoadError?: (err: any) => void\n    onError?: (err: any) => void\n    // This function is called\n    // when moving from an inactive state to an active one. Likewise, when moving from\n    // an active to an inactive state, the return function (if provided) is called.\n    onLoaded?: (matchContext: {\n      params: TAllParams\n      search: TFullSearchSchema\n    }) =>\n      | void\n      | undefined\n      | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n    // This function is called when the route remains active from one transition to the next.\n    onTransition?: (match: {\n      params: TAllParams\n      search: TFullSearchSchema\n    }) => void\n  } & MetaOptions &\n  ContextOptions<\n    TParentRoute,\n    TAllParams,\n    TFullSearchSchema,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext\n  > &\n  (\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<string, any>\n          ? TParams\n          : 'parseParams must return a Record<string, any>'\n        stringifyParams?: (\n          params: NoInfer<TParams>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? {}\n    : 'Cannot redefined path params in child routes!')\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  loaderContext: LoaderContext<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    TContext,\n    TAllContext\n  >,\n) => Promise<any> | void\n\nexport interface LoaderContext<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> {\n  params: TAllParams\n  routeSearch: TSearchSchema\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  preload: boolean\n  routeContext: TContext\n  context: TAllContext\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, Route>,\n) => void\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\ntype ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  isRoot: true\n  __types: {\n    searchSchema: infer TSearchSchema\n  }\n}\n  ? TSearchSchema\n  : TRoute extends {\n      __types: {\n        fullSearchSchema: infer TFullSearchSchema\n      }\n    }\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> =\n  InferFullSearchSchema<TParentRoute> & TSearchSchema\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\ntype MergeFromParent<T, U> = IsAny<T, U, T & U>\n\nexport class Route<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = string,\n  TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends string = string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends Record<ParsePathParams<TPath>, any> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends MergeFromParent<\n    TParentRoute['__types']['allParams'],\n    TParams\n  > = MergeFromParent<TParentRoute['__types']['allParams'], TParams>,\n  TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'],\n  TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'],\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TParentRoute['__types']['context'],\n    TRouteContext\n  > = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>,\n  TRouterContext extends AnyContext = AnyContext,\n  TChildren extends unknown = unknown,\n  TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo,\n> {\n  __types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    parentContext: TParentContext\n    allParentContext: TAllParentContext\n    routeContext: TRouteContext\n    context: TContext\n    children: TChildren\n    routesInfo: TRoutesInfo\n    routerContext: TRouterContext\n  }\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    InferFullSearchSchema<TParentRoute>,\n    TSearchSchema,\n    InferFullSearchSchema<TParentRoute> & TSearchSchema,\n    TParentRoute['__types']['allParams'],\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n  }\n\n  init = (opts: { originalIndex: number; router: AnyRouter }) => {\n    this.originalIndex = opts.originalIndex\n    this.router = opts.router\n\n    const allOptions = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    > &\n      RouteOptionsBaseIntersection<TCustomId, TPath>\n\n    const isRoot = !allOptions?.path && !allOptions?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : allOptions.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = allOptions?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId\n        ? '/'\n        : trimPathRight(joinPaths([this.parentRoute.fullPath, path]))\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TNewChildren,\n    TRoutesInfo\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  // generate = (\n  //   options: Omit<\n  //     RouteOptions<\n  //       TParentRoute,\n  //       TCustomId,\n  //       TPath,\n  //       InferFullSearchSchema<TParentRoute>,\n  //       TSearchSchema,\n  //       TFullSearchSchema,\n  //       TParentRoute['__types']['allParams'],\n  //       TParams,\n  //       TAllParams,\n  //       TParentContext,\n  //       TAllParentContext,\n  //       TRouteContext,\n  //       TContext\n  //     >,\n  //     'path'\n  //   >,\n  // ) => {\n  //   invariant(\n  //     false,\n  //     `route.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `,\n  //   )\n  // }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any>\n\nexport class RootRoute<\n  TSearchSchema extends AnySearchSchema = {},\n  TContext extends RouteContext = RouteContext,\n  TRouterContext extends RouterContext = RouterContext,\n> extends Route<\n  any,\n  '/',\n  '/',\n  string,\n  RootRouteId,\n  TSearchSchema,\n  TSearchSchema,\n  {},\n  {},\n  TRouterContext,\n  TRouterContext,\n  TContext,\n  MergeFromParent<TRouterContext, TContext>,\n  TRouterContext\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute,\n        RootRouteId,\n        '',\n        {},\n        TSearchSchema,\n        NoInfer<TSearchSchema>,\n        {},\n        TRouterContext,\n        TRouterContext,\n        TContext,\n        NoInfer<TContext>\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n\n  static withRouterContext = <TRouterContext extends RouterContext>() => {\n    return <\n      TSearchSchema extends AnySearchSchema = {},\n      TContext extends RouterContext = RouterContext,\n    >(\n      options?: Omit<\n        RouteOptions<\n          AnyRoute,\n          RootRouteId,\n          '',\n          {},\n          TSearchSchema,\n          NoInfer<TSearchSchema>,\n          {},\n          TRouterContext,\n          TRouterContext,\n          TContext,\n          TRouterContext & TContext\n        >,\n        'path' | 'id' | 'getParentRoute' | 'caseSensitive'\n      >,\n    ) => new RootRoute<TSearchSchema, TContext, TRouterContext>(options as any)\n  }\n}\n\ntype ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<\n    TParentRoute['fullPath'],\n    TPath\n  >,\n> = TPrefixed extends RootRouteId ? '/' : TrimPathRight<`${TPrefixed}`>\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TId extends string,\n> = string extends TId\n  ? RootRouteId\n  : TId extends string\n  ? TPrefix extends RootRouteId\n    ? TId extends '/'\n      ? '/'\n      : `/${TrimPath<TId>}`\n    : `${TPrefix}/${TId}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}`\n  : never\n\ntype TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\ntype TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}`\n  ? TrimPathLeft<U>\n  : T extends `/${infer U}`\n  ? TrimPathLeft<U>\n  : T\ntype TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\n// const rootRoute = new RootRoute({\n//   validateSearch: () => null as unknown as { root?: boolean },\n// })\n\n// const aRoute = new Route({\n//   getParentRoute: () => rootRoute,\n//   path: 'a',\n//   validateSearch: () => null as unknown as { a?: string },\n// })\n\n// const bRoute = new Route({\n//   getParentRoute: () => aRoute,\n//   path: 'b',\n// })\n\n// const rootIsRoot = rootRoute.isRoot\n// //    ^?\n// const aIsRoot = aRoute.isRoot\n// //    ^?\n\n// const rId = rootRoute.id\n// //    ^?\n// const aId = aRoute.id\n// //    ^?\n// const bId = bRoute.id\n// //    ^?\n\n// const rPath = rootRoute.fullPath\n// //    ^?\n// const aPath = aRoute.fullPath\n// //    ^?\n// const bPath = bRoute.fullPath\n// //    ^?\n\n// const rSearch = rootRoute.__types.fullSearchSchema\n// //    ^?\n// const aSearch = aRoute.__types.fullSearchSchema\n// //    ^?\n// const bSearch = bRoute.__types.fullSearchSchema\n// //    ^?\n\n// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])\n// //    ^?\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n","import { Store } from '@tanstack/store'\nimport invariant from 'tiny-invariant'\n\n//\n\nimport { GetFrameworkGeneric } from './frameworks'\n\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ToOptions,\n  ValidFromPath,\n  ResolveRelativePath,\n} from './link'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n} from './path'\nimport {\n  Route,\n  AnySearchSchema,\n  AnyRoute,\n  RootRoute,\n  AnyContext,\n} from './route'\nimport { RoutesInfo, AnyRoutesInfo, RoutesById } from './routeInfo'\nimport { AnyRouteMatch, RouteMatch, RouteMatchStore } from './routeMatch'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  functionalUpdate,\n  last,\n  NoInfer,\n  pick,\n  PickAsRequired,\n  Timeout,\n  Updater,\n  replaceEqualDeep,\n  partialDeepEqual,\n} from './utils'\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  RouterHistory,\n} from './history'\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? Router<TRoute, TRoutesInfo>\n  : Router\n\nexport type RegisteredRoutesInfo = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? TRoutesInfo\n  : AnyRoutesInfo\n\nexport interface LocationState {}\n\nexport interface ParsedLocation<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  href: string\n  pathname: string\n  search: TSearchObj\n  searchStr: string\n  state: TState\n  hash: string\n  key?: string\n}\n\nexport interface FromLocation {\n  pathname: string\n  search?: unknown\n  key?: string\n  hash?: string\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\nexport type FilterRoutesFn = <TRoute extends AnyRoute>(\n  routes: TRoute[],\n) => TRoute[]\n\ntype RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['__types']['routerContext']\n    ? {\n        context?: TRouteTree['__types']['routerContext']\n      }\n    : {\n        context: TRouteTree['__types']['routerContext']\n      }\n\nexport interface RouterOptions<TRouteTree extends AnyRoute> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  filterRoutes?: FilterRoutesFn\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: GetFrameworkGeneric<'Component'>\n  defaultErrorComponent?: GetFrameworkGeneric<'ErrorComponent'>\n  defaultPendingComponent?: GetFrameworkGeneric<'Component'>\n  defaultLoaderMaxAge?: number\n  defaultLoaderGcMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  Router?: (router: AnyRouter) => void\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  loadComponent?: (\n    component: GetFrameworkGeneric<'Component'>,\n  ) => Promise<GetFrameworkGeneric<'Component'>>\n  onRouteChange?: () => void\n  fetchServerDataFn?: FetchServerDataFn\n  context?: TRouteTree['__types']['routerContext']\n}\n\ntype FetchServerDataFn = (ctx: {\n  router: AnyRouter\n  routeMatch: RouteMatch\n}) => Promise<any>\n\nexport interface RouterStore<\n  TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo,\n  TState extends LocationState = LocationState,\n> {\n  status: 'idle' | 'pending'\n  latestLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  currentMatches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  currentLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  pendingMatches?: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  pendingLocation?: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  lastUpdated: number\n}\n\nexport type ListenerFn = () => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: LocationState\n  key?: string\n  from?: string\n  fromCurrent?: boolean\n  __matches?: RouteMatch[]\n}\n\nexport type MatchCacheEntry = {\n  gc: number\n  match: RouteMatch\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n  fromCurrent?: boolean\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport interface DehydratedRouterState\n  extends Pick<\n    RouterStore,\n    'status' | 'latestLocation' | 'currentLocation' | 'lastUpdated'\n  > {\n  currentMatches: DehydratedRouteMatch[]\n}\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type MatchCache = Record<string, MatchCacheEntry>\n\ninterface DehydratedRouteMatch {\n  id: string\n  state: Pick<RouteMatchStore<any, any>, 'status'>\n}\n\nexport interface RouterContext {}\n\nexport const defaultFetchServerDataFn: FetchServerDataFn = async ({\n  router,\n  routeMatch,\n}) => {\n  const next = router.buildNext({\n    to: '.',\n    search: (d: any) => ({\n      ...(d ?? {}),\n      __data: {\n        matchId: routeMatch.id,\n      },\n    }),\n  })\n\n  const res = await fetch(next.href, {\n    method: 'GET',\n    signal: routeMatch.abortController.signal,\n  })\n\n  if (res.ok) {\n    return res.json()\n  }\n\n  throw new Error('Failed to fetch match data')\n}\n\nexport type RouterConstructorOptions<TRouteTree extends AnyRoute> = Omit<\n  RouterOptions<TRouteTree>,\n  'context'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport class Router<\n  TRouteTree extends AnyRoute = RootRoute,\n  TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>,\n> {\n  types!: {\n    // Super secret internal stuff\n    RootRoute: TRouteTree\n    RoutesInfo: TRoutesInfo\n  }\n\n  options: PickAsRequired<\n    RouterOptions<TRouteTree>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  #unsubHistory?: () => void\n  basepath: string\n  // __location: Location<TRoutesInfo['fullSearchSchema']>\n  routeTree!: RootRoute\n  routesById!: RoutesById<TRoutesInfo>\n  navigateTimeout: undefined | Timeout\n  nextAction: undefined | 'push' | 'replace'\n  navigationPromise: undefined | Promise<void>\n\n  __store: Store<RouterStore<TRoutesInfo>>\n  state: RouterStore<TRoutesInfo>\n  startedLoadingAt = Date.now()\n  resolveNavigation: () => void = () => {}\n\n  constructor(options?: RouterConstructorOptions<TRouteTree>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,\n    }\n\n    this.__store = new Store<RouterStore<TRoutesInfo>>(\n      getInitialRouterState(),\n      {\n        onUpdate: (state) => {\n          this.state = state\n        },\n      },\n    )\n    this.state = this.__store.state\n    this.basepath = ''\n\n    this.update(options)\n\n    // Allow frameworks to hook into the router creation\n    this.options.Router?.(this)\n\n    const next = this.buildNext({\n      hash: true,\n      fromCurrent: true,\n      search: true,\n      state: true,\n    })\n\n    if (this.state.latestLocation.href !== next.href) {\n      this.#commitLocation({ ...next, replace: true })\n    }\n  }\n\n  reset = () => {\n    this.__store.setState((s) => Object.assign(s, getInitialRouterState()))\n  }\n\n  mount = () => {\n    // Mount only does anything on the client\n    if (!isServer) {\n      // If the router matches are empty, start loading the matches\n      if (!this.state.currentMatches.length) {\n        this.safeLoad()\n      }\n    }\n\n    return () => {}\n  }\n\n  update = (opts?: RouterOptions<TRouteTree>): this => {\n    Object.assign(this.options, opts)\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (this.#unsubHistory) {\n        this.#unsubHistory()\n      }\n\n      this.history =\n        this.options.history ??\n        (isServer ? createMemoryHistory() : createBrowserHistory()!)\n\n      const parsedLocation = this.#parseLocation()\n\n      this.__store.setState((s) => ({\n        ...s,\n        latestLocation: parsedLocation,\n        currentLocation: parsedLocation,\n      }))\n\n      this.#unsubHistory = this.history.listen(() => {\n        this.safeLoad({\n          next: this.#parseLocation(this.state.latestLocation),\n        })\n      })\n    }\n\n    const { basepath, routeTree } = this.options\n\n    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`\n\n    if (routeTree) {\n      this.routesById = {} as any\n      this.routeTree = this.#buildRouteTree(routeTree)\n    }\n\n    return this\n  }\n\n  buildNext = (opts: BuildNextOptions) => {\n    const next = this.#buildLocation(opts)\n\n    const __matches = this.matchRoutes(next.pathname)\n\n    return this.#buildLocation({\n      ...opts,\n      __matches,\n    })\n  }\n\n  cancelMatches = () => {\n    ;[\n      ...this.state.currentMatches,\n      ...(this.state.pendingMatches || []),\n    ].forEach((match) => {\n      match.cancel()\n    })\n  }\n\n  safeLoad = (opts?: { next?: ParsedLocation }) => {\n    this.load(opts).catch((err) => {\n      console.warn(err)\n      invariant(false, 'Encountered an error during router.load()! ☝️.')\n    })\n  }\n\n  load = async (opts?: { next?: ParsedLocation }): Promise<void> => {\n    let now = Date.now()\n    const startedAt = now\n    this.startedLoadingAt = startedAt\n\n    // Cancel any pending matches\n    this.cancelMatches()\n\n    let matches!: RouteMatch<any, any>[]\n\n    this.__store.batch(() => {\n      if (opts?.next) {\n        // Ingest the new location\n        this.__store.setState((s) => ({\n          ...s,\n          latestLocation: opts.next!,\n        }))\n      }\n\n      // Match the routes\n      matches = this.matchRoutes(this.state.latestLocation.pathname, {\n        strictParseParams: true,\n      })\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'pending',\n        pendingMatches: matches,\n        pendingLocation: this.state.latestLocation,\n      }))\n    })\n\n    // Load the matches\n    await this.loadMatches(\n      matches,\n      this.state.pendingLocation!,\n      // opts\n    )\n\n    if (this.startedLoadingAt !== startedAt) {\n      // Ignore side-effects of outdated side-effects\n      return this.navigationPromise\n    }\n\n    const previousMatches = this.state.currentMatches\n\n    const exiting: AnyRouteMatch[] = [],\n      staying: AnyRouteMatch[] = []\n\n    previousMatches.forEach((d) => {\n      if (matches.find((dd) => dd.id === d.id)) {\n        staying.push(d)\n      } else {\n        exiting.push(d)\n      }\n    })\n\n    const entering = matches.filter((d) => {\n      return !previousMatches.find((dd) => dd.id === d.id)\n    })\n\n    now = Date.now()\n\n    exiting.forEach((d) => {\n      d.__onExit?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n\n      // Clear non-loading error states when match leaves\n      if (d.state.status === 'error') {\n        this.__store.setState((s) => ({\n          ...s,\n          status: 'idle',\n          error: undefined,\n        }))\n      }\n    })\n\n    staying.forEach((d) => {\n      d.route.options.onTransition?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n    })\n\n    entering.forEach((d) => {\n      d.__onExit = d.route.options.onLoaded?.({\n        params: d.params,\n        search: d.state.search,\n      })\n    })\n\n    const prevLocation = this.state.currentLocation\n\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'idle',\n      currentLocation: this.state.latestLocation,\n      currentMatches: matches,\n      pendingLocation: undefined,\n      pendingMatches: undefined,\n    }))\n\n    matches.forEach((match) => {\n      match.__commit()\n    })\n\n    if (prevLocation!.href !== this.state.currentLocation.href) {\n      this.options.onRouteChange?.()\n    }\n\n    this.resolveNavigation()\n  }\n\n  getRoute = <TId extends keyof TRoutesInfo['routesById']>(\n    id: TId,\n  ): TRoutesInfo['routesById'][TId] => {\n    const route = this.routesById[id]\n\n    invariant(route, `Route with id \"${id as string}\" not found`)\n\n    return route\n  }\n\n  loadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.latestLocation,\n  ): Promise<RouteMatch[]> => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n    await this.loadMatches(matches, next)\n    return matches\n  }\n\n  preloadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.latestLocation,\n  ) => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n\n    await this.loadMatches(matches, next, {\n      preload: true,\n    })\n    return matches\n  }\n\n  matchRoutes = (pathname: string, opts?: { strictParseParams?: boolean }) => {\n    const matches: AnyRouteMatch[] = []\n\n    if (!this.routeTree) {\n      return matches\n    }\n\n    const existingMatches = [\n      ...this.state.currentMatches,\n      ...(this.state.pendingMatches ?? []),\n    ]\n\n    const findInRouteTree = async (\n      routes: Route<any, any>[],\n    ): Promise<void> => {\n      const parentMatch = last(matches)\n      let params = parentMatch?.params ?? {}\n\n      const filteredRoutes = this.options.filterRoutes?.(routes) ?? routes\n\n      let matchingRoutes: Route[] = []\n\n      const findMatchInRoutes = (parentRoutes: Route[], routes: Route[]) => {\n        routes.some((route) => {\n          const children = route.children as undefined | Route[]\n          if (!route.path && children?.length) {\n            return findMatchInRoutes(\n              [...matchingRoutes, route],\n              children as any,\n            )\n          }\n\n          const fuzzy = !!(route.path !== '/' || children?.length)\n\n          const matchParams = matchPathname(this.basepath, pathname, {\n            to: route.fullPath,\n            fuzzy,\n            caseSensitive:\n              route.options.caseSensitive ?? this.options.caseSensitive,\n          })\n\n          if (matchParams) {\n            let parsedParams\n\n            try {\n              parsedParams =\n                route.options.parseParams?.(matchParams!) ?? matchParams\n            } catch (err) {\n              if (opts?.strictParseParams) {\n                throw err\n              }\n            }\n\n            params = {\n              ...params,\n              ...parsedParams,\n            }\n          }\n\n          if (!!matchParams) {\n            matchingRoutes = [...parentRoutes, route]\n          }\n\n          return !!matchingRoutes.length\n        })\n\n        return !!matchingRoutes.length\n      }\n\n      findMatchInRoutes([], filteredRoutes)\n\n      if (!matchingRoutes.length) {\n        return\n      }\n\n      matchingRoutes.forEach((foundRoute) => {\n        const interpolatedPath = interpolatePath(foundRoute.path, params)\n        const matchId = interpolatePath(foundRoute.id, params, true)\n\n        const match =\n          existingMatches.find((d) => d.id === matchId) ||\n          new RouteMatch(this, foundRoute, {\n            id: matchId,\n            params,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n          })\n\n        matches.push(match)\n      })\n\n      const foundRoute = last(matchingRoutes)!\n\n      const foundChildren = foundRoute.children as any\n\n      if (foundChildren?.length) {\n        findInRouteTree(foundChildren)\n      }\n    }\n\n    findInRouteTree([this.routeTree as any])\n\n    return matches\n  }\n\n  loadMatches = async (\n    resolvedMatches: RouteMatch[],\n    location: ParsedLocation,\n    opts?: {\n      preload?: boolean\n      // filter?: (match: RouteMatch<any, any>) => any\n    },\n  ) => {\n    let firstBadMatchIndex: number | undefined\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      await Promise.all(\n        resolvedMatches.map(async (match, index) => {\n          try {\n            await match.route.options.beforeLoad?.({\n              router: this as any,\n              match,\n            })\n          } catch (err) {\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            const errorHandler = match.route.options.onBeforeLoadError ?? match.route.options.onError\n            try {\n              errorHandler?.(err)\n            } catch (errorHandlerErr) {\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n\n              match.__store.setState((s) => ({\n                ...s,\n                error: errorHandlerErr,\n                status: 'error',\n                updatedAt: Date.now(),\n              }))\n              return\n            }\n\n            match.__store.setState((s) => ({\n              ...s,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }))\n          }\n        }),\n      )\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.navigate(err as any)\n        }\n        return\n      }\n\n      throw err // we should never end up here\n    }\n\n    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex)\n    const matchPromises = validResolvedMatches.map(async (match, index) => {\n      const parentMatch = validResolvedMatches[index - 1]\n\n      match.__load({ preload: opts?.preload, location, parentMatch })\n\n      await match.__loadPromise\n\n      if (parentMatch) {\n        await parentMatch.__loadPromise\n      }\n    })\n\n    await Promise.all(matchPromises)\n  }\n\n  reload = () => {\n    this.navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true,\n    } as any)\n  }\n\n  resolvePath = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  navigate = async <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n  >({\n    from,\n    to = '' as any,\n    search,\n    hash,\n    replace,\n    params,\n  }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.#commitLocation({\n      from: fromString,\n      to: toString,\n      search,\n      hash,\n      replace,\n      params,\n    })\n  }\n\n  matchRoute = <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n    TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<TRoutesInfo, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ): false | TRoutesInfo['routesById'][TResolved]['__types']['allParams'] => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePath(location.from ?? '', location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildNext(location)\n    const baseLocation = opts?.pending\n      ? this.state.pendingLocation\n      : this.state.currentLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (opts?.includeSearch ?? true) {\n      return partialDeepEqual(baseLocation.search, next.search) ? match : false\n    }\n\n    return match\n  }\n\n  buildLink = <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n  >({\n    from,\n    to = '.' as any,\n    search,\n    params,\n    hash,\n    target,\n    replace,\n    activeOptions,\n    preload,\n    preloadDelay: userPreloadDelay,\n    disabled,\n  }: LinkOptions<TRoutesInfo, TFrom, TTo>): LinkInfo => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to,\n      }\n    } catch (e) {}\n\n    const nextOpts = {\n      from,\n      to,\n      search,\n      params,\n      hash,\n      replace,\n    }\n\n    const next = this.buildNext(nextOpts)\n\n    preload = preload ?? this.options.defaultPreload\n    const preloadDelay =\n      userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = this.state.currentLocation.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? this.state.currentLocation.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? this.state.currentLocation.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(this.state.currentLocation.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        this.#commitLocation(nextOpts as any)\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        this.preloadRoute(nextOpts).catch((err) => {\n          console.warn(err)\n          console.warn('Error preloading route! ☝️')\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      this.preloadRoute(nextOpts).catch((err) => {\n        console.warn(err)\n        console.warn('Error preloading route! ☝️')\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          this.preloadRoute(nextOpts).catch((err) => {\n            console.warn(err)\n            console.warn('Error preloading route! ☝️')\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        ...pick(this.state, [\n          'latestLocation',\n          'currentLocation',\n          'status',\n          'lastUpdated',\n        ]),\n        currentMatches: this.state.currentMatches.map((match) => ({\n          id: match.id,\n          state: {\n            status: match.state.status,\n          },\n        })),\n      },\n    }\n  }\n\n  hydrate = (dehydratedRouter: DehydratedRouter) => {\n    this.__store.setState((s) => {\n      // Match the routes\n      const currentMatches = this.matchRoutes(\n        dehydratedRouter.state.latestLocation.pathname,\n        {\n          strictParseParams: true,\n        },\n      )\n\n      currentMatches.forEach((match, index) => {\n        const dehydratedMatch = dehydratedRouter.state.currentMatches[index]\n        invariant(\n          dehydratedMatch && dehydratedMatch.id === match.id,\n          'Oh no! There was a hydration mismatch when attempting to hydrate the state of the router! 😬',\n        )\n        match.__store.setState((s) => ({\n          ...s,\n          ...dehydratedMatch.state,\n        }))\n      })\n\n      return {\n        ...s,\n        ...dehydratedRouter.state,\n        currentMatches,\n      }\n    })\n  }\n\n  #buildRouteTree = (routeTree: AnyRoute) => {\n    const recurseRoutes = (routes: Route[], parentRoute: Route | undefined) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i, router: this })\n\n        const existingRoute = (this.routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(this.routesById as any)[route.id] = route\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children, route)\n\n          route.children = children\n            .map((d, i) => {\n              const parsed = parsePathname(\n                trimPathLeft(cleanPath(d.path ?? '/')),\n              )\n\n              while (parsed.length > 1 && parsed[0]?.value === '/') {\n                parsed.shift()\n              }\n\n              let score = 0\n\n              parsed.forEach((d, i) => {\n                let modifier = 1\n                while (i--) {\n                  modifier *= 0.001\n                }\n                if (d.type === 'pathname' && d.value !== '/') {\n                  score += 1 * modifier\n                } else if (d.type === 'param') {\n                  score += 2 * modifier\n                } else if (d.type === 'wildcard') {\n                  score += 3 * modifier\n                }\n              })\n\n              return { child: d, parsed, index: i, score }\n            })\n            .sort((a, b) => {\n              if (a.score !== b.score) {\n                return a.score - b.score\n              }\n\n              return a.index - b.index\n            })\n            .map((d) => d.child)\n        }\n      })\n    }\n\n    recurseRoutes([routeTree] as Route[], undefined)\n\n    const recurceCheckRoutes = (\n      routes: Route[],\n      parentRoute: Route | undefined,\n    ) => {\n      routes.forEach((route) => {\n        if (route.isRoot) {\n          invariant(\n            !parentRoute,\n            'Root routes can only be used as the root of a route tree.',\n          )\n        } else {\n          invariant(\n            parentRoute ? route.parentRoute === parentRoute : true,\n            `Expected a route with path \"${route.path}\" to be passed to its parent route \"${route.parentRoute?.id}\" in an addChildren() call, but was instead passed as a child of the \"${parentRoute?.id}\" route.`,\n          )\n        }\n\n        if (route.children) {\n          recurceCheckRoutes(route.children as Route[], route)\n        }\n      })\n    }\n\n    recurceCheckRoutes([routeTree] as Route[], undefined)\n\n    return routeTree\n  }\n\n  #parseLocation = (previousLocation?: ParsedLocation): ParsedLocation => {\n    let { pathname, search, hash, state } = this.history.location\n\n    const parsedSearch = this.options.parseSearch(search)\n\n    return {\n      pathname: pathname,\n      searchStr: search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: hash.split('#').reverse()[0] ?? '',\n      href: `${pathname}${search}${hash}`,\n      state: state as LocationState,\n      key: state?.key || '__init__',\n    }\n  }\n\n  #buildLocation = (dest: BuildNextOptions = {}): ParsedLocation => {\n    dest.fromCurrent = dest.fromCurrent ?? dest.to === ''\n\n    const fromPathname = dest.fromCurrent\n      ? this.state.latestLocation.pathname\n      : dest.from ?? this.state.latestLocation.pathname\n\n    let pathname = resolvePath(\n      this.basepath ?? '/',\n      fromPathname,\n      `${dest.to ?? ''}`,\n    )\n\n    const fromMatches = this.matchRoutes(this.state.latestLocation.pathname, {\n      strictParseParams: true,\n    })\n\n    const prevParams = { ...last(fromMatches)?.params }\n\n    let nextParams =\n      (dest.params ?? true) === true\n        ? prevParams\n        : functionalUpdate(dest.params!, prevParams)\n\n    if (nextParams) {\n      dest.__matches\n        ?.map((d) => d.route.options.stringifyParams)\n        .filter(Boolean)\n        .forEach((fn) => {\n          nextParams = { ...nextParams!, ...fn!(nextParams!) }\n        })\n    }\n\n    pathname = interpolatePath(pathname, nextParams ?? {})\n\n    const preSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.preSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    const postSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.postSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    // Pre filters first\n    const preFilteredSearch = preSearchFilters?.length\n      ? preSearchFilters?.reduce(\n          (prev, next) => next(prev),\n          this.state.latestLocation.search,\n        )\n      : this.state.latestLocation.search\n\n    // Then the link/navigate function\n    const destSearch =\n      dest.search === true\n        ? preFilteredSearch // Preserve resolvedFrom true\n        : dest.search\n        ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n        : preSearchFilters?.length\n        ? preFilteredSearch // Preserve resolvedFrom filters\n        : {}\n\n    // Then post filters\n    const postFilteredSearch = postSearchFilters?.length\n      ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n      : destSearch\n\n    const search = replaceEqualDeep(\n      this.state.latestLocation.search,\n      postFilteredSearch,\n    )\n\n    const searchStr = this.options.stringifySearch(search)\n    let hash =\n      dest.hash === true\n        ? this.state.latestLocation.hash\n        : functionalUpdate(dest.hash!, this.state.latestLocation.hash)\n    hash = hash ? `#${hash}` : ''\n\n    const nextState =\n      dest.state === true\n        ? this.state.latestLocation.state\n        : functionalUpdate(dest.state, this.state.latestLocation.state)!\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: nextState,\n      hash,\n      href: this.history.createHref(`${pathname}${searchStr}${hash}`),\n      key: dest.key,\n    }\n  }\n\n  #commitLocation = async (\n    location: BuildNextOptions & { replace?: boolean },\n  ) => {\n    const next = this.buildNext(location)\n    const id = '' + Date.now() + Math.random()\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!location.replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl = this.state.latestLocation.href === next.href\n\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace'\n    }\n\n    const href = `${next.pathname}${next.searchStr}${\n      next.hash ? `#${next.hash}` : ''\n    }`\n\n    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {\n      id,\n      ...next.state,\n    })\n\n    return (this.navigationPromise = new Promise((resolve) => {\n      const previousNavigationResolve = this.resolveNavigation\n\n      this.resolveNavigation = () => {\n        previousNavigationResolve()\n        resolve()\n      }\n    }))\n  }\n}\n\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !window.document.createElement\n\nfunction getInitialRouterState(): RouterStore<any, any> {\n  return {\n    status: 'idle',\n    latestLocation: null!,\n    currentLocation: null!,\n    currentMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport type AnyRedirect = Redirect<any, any, any>\n\nexport type Redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {\n  code?: number\n}\n\nexport function redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo> {\n  ;(opts as any).isRedirect = true\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n","import { Store } from '@tanstack/store'\n//\nimport { GetFrameworkGeneric } from './frameworks'\nimport { AnyRoute, AnySearchSchema, Route } from './route'\nimport { AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport { AnyRouter, isRedirect, ParsedLocation, Router } from './router'\nimport { Expand, pick, replaceEqualDeep } from './utils'\n\nexport interface RouteMatchStore<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = Route,\n> {\n  routeSearch: TRoute['__types']['searchSchema']\n  search: TRoutesInfo['fullSearchSchema'] &\n    TRoute['__types']['fullSearchSchema']\n  status: 'idle' | 'pending' | 'success' | 'error'\n  error?: unknown\n  updatedAt: number\n}\n\nconst componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport interface PendingRouteMatchInfo {\n  state: RouteMatchStore<any, any>\n  routeContext: {}\n  context: {}\n}\n\nexport interface AnyRouteMatch extends RouteMatch<any, any> {}\n\nexport class RouteMatch<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = AnyRoute,\n> {\n  route!: TRoute\n  router!: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n  __store!: Store<RouteMatchStore<TRoutesInfo, TRoute>>\n  state!: RouteMatchStore<TRoutesInfo, TRoute>\n  id!: string\n  pathname!: string\n  params!: TRoute['__types']['allParams']\n\n  routeContext?: TRoute['__types']['routeContext']\n  context?: TRoute['__types']['context']\n\n  component?: GetFrameworkGeneric<'Component'>\n  errorComponent?: GetFrameworkGeneric<'ErrorComponent'>\n  pendingComponent?: GetFrameworkGeneric<'Component'>\n  abortController = new AbortController()\n  parentMatch?: RouteMatch\n  pendingInfo?: PendingRouteMatchInfo\n\n  __loadPromise?: Promise<void>\n  __onExit?:\n    | void\n    | ((matchContext: {\n        params: TRoute['__types']['allParams']\n        search: TRoute['__types']['fullSearchSchema']\n      }) => void)\n\n  constructor(\n    router: AnyRouter,\n    route: TRoute,\n    opts: {\n      id: string\n      params: TRoute['__types']['allParams']\n      pathname: string\n    },\n  ) {\n    Object.assign(this, {\n      route,\n      router,\n      id: opts.id,\n      pathname: opts.pathname,\n      params: opts.params,\n      __store: new Store<RouteMatchStore<TRoutesInfo, TRoute>>(\n        {\n          updatedAt: 0,\n          routeSearch: {},\n          search: {} as any,\n          status: 'idle',\n        },\n        {\n          onUpdate: (next) => {\n            this.state = next\n          },\n        },\n      ),\n    })\n\n    this.state = this.__store.state\n\n    componentTypes.map(async (type) => {\n      const component = this.route.options[type]\n\n      if (typeof this[type] !== 'function') {\n        this[type] = component\n      }\n    })\n\n    if (this.state.status === 'idle' && !this.#hasLoaders()) {\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'success',\n      }))\n    }\n  }\n\n  #hasLoaders = () => {\n    return !!(\n      this.route.options.onLoad ||\n      componentTypes.some((d) => this.route.options[d]?.preload)\n    )\n  }\n\n  __commit = () => {\n    const { routeSearch, search, context, routeContext } = this.#resolveInfo({\n      location: this.router.state.currentLocation,\n    })\n    this.context = context\n    this.routeContext = routeContext\n    this.__store.setState((s) => ({\n      ...s,\n      routeSearch: replaceEqualDeep(s.routeSearch, routeSearch),\n      search: replaceEqualDeep(s.search, search),\n    }))\n  }\n\n  cancel = () => {\n    this.abortController?.abort()\n  }\n\n  #resolveSearchInfo = (opts: {\n    location: ParsedLocation\n  }): { routeSearch: {}; search: {} } => {\n    // Validate the search params and stabilize them\n    const parentSearchInfo = this.parentMatch\n      ? this.parentMatch.#resolveSearchInfo(opts)\n      : { search: opts.location.search, routeSearch: opts.location.search }\n\n    try {\n      const validator =\n        typeof this.route.options.validateSearch === 'object'\n          ? this.route.options.validateSearch.parse\n          : this.route.options.validateSearch\n\n      const routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n      const search = {\n        ...parentSearchInfo.search,\n        ...routeSearch,\n      }\n\n      return {\n        routeSearch,\n        search,\n      }\n    } catch (err: any) {\n      if (isRedirect(err)) {\n        throw err\n      }\n\n      const errorHandler = this.route.options.onValidateSearchError ?? this.route.options.onError\n      errorHandler?.(err)\n      const error = new (Error as any)('Invalid search params found', {\n        cause: err,\n      })\n      error.code = 'INVALID_SEARCH_PARAMS'\n\n      throw error\n    }\n  }\n\n  #resolveInfo = (opts: { location: ParsedLocation }) => {\n    const { search, routeSearch } = this.#resolveSearchInfo(opts)\n\n    try {\n      const routeContext =\n        this.route.options.getContext?.({\n          parentContext: this.parentMatch?.routeContext ?? {},\n          context:\n            this.parentMatch?.context ?? this.router?.options.context ?? {},\n          params: this.params,\n          search,\n        }) || ({} as any)\n\n        const context = {\n          ...(this.parentMatch?.context ?? this.router?.options.context),\n          ...routeContext,\n        } as any\n    \n        return {\n          routeSearch,\n          search,\n          context,\n          routeContext,\n        }\n    } catch (err) {\n      this.route.options.onError?.(err)\n      throw err\n    }\n  }\n\n  __load = async (opts: {\n    parentMatch: RouteMatch | undefined\n    preload?: boolean\n    location: ParsedLocation\n  }): Promise<void> => {\n    this.parentMatch = opts.parentMatch\n\n    let info\n\n    try {\n      info = this.#resolveInfo(opts)\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.router.navigate(err as any)\n        }\n        return\n      }\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'error',\n        error: err,\n      }))\n\n      // Do not proceed with loading the route\n      return\n    }\n\n    const { routeSearch, search, context, routeContext } = info\n\n    // If the match is invalid, errored or idle, trigger it to load\n    if (this.state.status === 'pending') {\n      return\n    }\n\n    // TODO: Should load promises be tracked based on location?\n    this.__loadPromise = Promise.resolve().then(async () => {\n      const loadId = '' + Date.now() + Math.random()\n      this.#latestId = loadId\n\n      const checkLatest = () => {\n        return loadId !== this.#latestId ? this.__loadPromise : undefined\n      }\n\n      let latestPromise\n\n      // If the match was in an error state, set it\n      // to a loading state again. Otherwise, keep it\n      // as loading or resolved\n      if (this.state.status === 'idle') {\n        this.__store.setState((s) => ({\n          ...s,\n          status: 'pending',\n        }))\n      }\n\n      const componentsPromise = (async () => {\n        // then run all component and data loaders in parallel\n        // For each component type, potentially load it asynchronously\n\n        await Promise.all(\n          componentTypes.map(async (type) => {\n            const component = this.route.options[type]\n\n            if (this[type]?.preload) {\n              this[type] = await this.router.options.loadComponent!(component)\n            }\n          }),\n        )\n      })()\n\n      const dataPromise = Promise.resolve().then(() => {\n        if (this.route.options.onLoad) {\n          return this.route.options.onLoad({\n            params: this.params,\n            routeSearch,\n            search,\n            signal: this.abortController.signal,\n            preload: !!opts?.preload,\n            routeContext: routeContext,\n            context: context,\n          })\n        }\n        return\n      })\n\n      try {\n        await Promise.all([componentsPromise, dataPromise])\n        if ((latestPromise = checkLatest())) return await latestPromise\n        this.__store.setState((s) => ({\n          ...s,\n          error: undefined,\n          status: 'success',\n          updatedAt: Date.now(),\n        }))\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!opts?.preload) {\n            this.router.navigate(err as any)\n          }\n          return\n        }\n\n        const errorHandler = this.route.options.onLoadError ?? this.route.options.onError\n        try {\n          errorHandler?.(err)\n        } catch (errorHandlerErr) {\n          if (isRedirect(errorHandlerErr)) {\n            if (!opts?.preload) {\n              this.router.navigate(errorHandlerErr as any)\n            }\n            return\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            error: errorHandlerErr,\n            status: 'error',\n            updatedAt: Date.now(),\n          }))\n          return\n        }\n\n        this.__store.setState((s) => ({\n          ...s,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now(),\n        }))\n      } finally {\n        delete this.__loadPromise\n      }\n    })\n\n    return this.__loadPromise\n  }\n\n  #latestId = ''\n}\n"],"names":["popStateEvent","beforeUnloadEvent","beforeUnloadListener","event","preventDefault","returnValue","stopBlocking","removeEventListener","capture","createHistory","opts","currentLocation","getLocation","unsub","listeners","Set","blockers","queue","tryFlush","length","shift","onUpdate","queueTask","task","push","forEach","listener","location","listen","cb","size","add","delete","path","state","pushState","replace","replaceState","go","index","back","forward","createHref","str","block","addEventListener","filter","b","createBrowserHistory","getHref","window","pathname","hash","search","parseLocation","history","key","createRandomKey","n","createHashHistory","substring","createMemoryHistory","initialEntries","entries","initialIndex","currentState","Math","min","href","hashIndex","indexOf","searchIndex","random","toString","last","arr","isFunction","d","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","replaceEqualDeep","prev","_next","next","array","Array","isArray","isPlainObject","prevSize","Object","nextItems","nextSize","copy","equalItems","i","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","call","partialDeepEqual","a","some","every","item","joinPaths","paths","cleanPath","Boolean","join","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","toSegment","value","pop","joined","map","segments","slice","type","split","part","charAt","interpolatePath","params","leaveWildcard","interpolatedPathSegments","segment","includes","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","startsWith","undefined","routeSegments","isMatch","max","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","caseSensitive","toLowerCase","fuzzy","encode","pfx","k","tmp","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","concat","rootRouteId","Route","options","isRoot","getParentRoute","init","originalIndex","router","allOptions","id","parentRoute","invariant","customId","fullPath","addChildren","children","RootRoute","withRouterContext","defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","err","val","defaultFetchServerDataFn","routeMatch","buildNext","__data","matchId","res","fetch","method","signal","abortController","ok","json","Error","Router","startedLoadingAt","Date","now","resolveNavigation","defaultPreloadDelay","context","stringifySearch","parseSearch","fetchServerDataFn","__store","Store","getInitialRouterState","update","fromCurrent","latestLocation","reset","setState","s","assign","mount","isServer","currentMatches","safeLoad","parsedLocation","routeTree","routesById","__matches","matchRoutes","cancelMatches","pendingMatches","match","cancel","load","catch","console","warn","startedAt","matches","batch","strictParseParams","status","pendingLocation","loadMatches","navigationPromise","previousMatches","exiting","staying","find","dd","entering","__onExit","routeSearch","error","route","onTransition","onLoaded","prevLocation","__commit","onRouteChange","getRoute","loadRoute","navigateOpts","preloadRoute","preload","existingMatches","findInRouteTree","routes","parentMatch","filteredRoutes","filterRoutes","matchingRoutes","findMatchInRoutes","parentRoutes","matchParams","parsedParams","parseParams","foundRoute","interpolatedPath","RouteMatch","foundChildren","resolvedMatches","firstBadMatchIndex","Promise","all","beforeLoad","isRedirect","errorHandler","onBeforeLoadError","onError","errorHandlerErr","updatedAt","navigate","validResolvedMatches","matchPromises","__load","__loadPromise","reload","String","fromString","isExternal","URL","e","matchRoute","baseLocation","pending","includeSearch","buildLink","target","activeOptions","preloadDelay","userPreloadDelay","disabled","nextOpts","defaultPreload","currentPathSplit","nextPathSplit","pathIsFuzzyEqual","pathTest","exact","hashTest","includeHash","searchTest","isActive","handleClick","isCtrlEvent","defaultPrevented","button","handleFocus","handleTouchStart","handleEnter","preloadTimeout","setTimeout","handleLeave","clearTimeout","dehydrate","hydrate","dehydratedRouter","dehydratedMatch","recurseRoutes","existingRoute","parsed","score","modifier","child","sort","recurceCheckRoutes","previousLocation","parsedSearch","reverse","dest","fromPathname","fromMatches","prevParams","nextParams","stringifyParams","fn","preSearchFilters","flat","postSearchFilters","preFilteredSearch","destSearch","postFilteredSearch","nextState","navigateTimeout","nextAction","isSameUrl","resolve","previousNavigationResolve","document","createElement","lastUpdated","metaKey","altKey","ctrlKey","shiftKey","redirect","componentTypes","AbortController","component","onLoad","routeContext","abort","parentSearchInfo","validator","validateSearch","onValidateSearchError","cause","code","getContext","parentContext","info","then","loadId","checkLatest","latestPromise","componentsPromise","loadComponent","dataPromise","onLoadError"],"mappings":"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"}